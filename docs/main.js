/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={424:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),s=n(645),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var p=this[o][0];null!=p&&(r[p]=!0)}for(var d=0;d<e.length;d++){var l=[].concat(e[d]);a&&r[l[0]]||(void 0!==s&&(void 0===l[5]||(l[1]="@layer".concat(l[5].length>0?" ".concat(l[5]):""," {").concat(l[1],"}")),l[5]=s),n&&(l[2]?(l[1]="@media ".concat(l[2]," {").concat(l[1],"}"),l[2]=n):l[2]=n),i&&(l[4]?(l[1]="@supports (".concat(l[4],") {").concat(l[1],"}"),l[4]=i):l[4]="".concat(i)),t.push(l))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},838:(e,t,n)=>{var a=n(424);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("20211576",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,p=0,d=!1,l=function(){},u=null,y="data-vue-ssr-id",c="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){d=n,u=i||{};var r=a(e,t);return f(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(p=s[o.id]).refs--,n.push(p)}for(t?f(r=a(e,t)):r=[],i=0;i<n.length;i++){var p;if(0===(p=n[i]).refs){for(var d=0;d<p.parts.length;d++)p.parts[d]();delete s[p.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(b(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(b(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function h(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function b(e){var t,n,a=document.querySelector("style["+y+'~="'+e.id+'"]');if(a){if(d)return l;a.parentNode.removeChild(a)}if(c){var i=p++;a=o||(o=h()),t=g.bind(null,a,i,!1),n=g.bind(null,a,i,!0)}else a=h(),t=w.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var v,T=(v=[],function(e,t){return v[e]=t,v.filter(Boolean).join("\n")});function g(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=T(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function w(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),u.ssrId&&e.setAttribute(y,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function s(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return"function"==typeof e}function p(e){return null!==e&&"object"==typeof e}var d=Object.prototype.toString;function l(e){return"[object Object]"===d.call(e)}function u(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function y(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function c(e){return null==e?"":Array.isArray(e)||l(e)&&e.toString===d?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function f(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var h=f("slot,component",!0),b=f("key,ref,slot,slot-scope,is");function v(e,t){var n=e.length;if(n){if(t===e[n-1])return void(e.length=n-1);var a=e.indexOf(t);if(a>-1)return e.splice(a,1)}}var T=Object.prototype.hasOwnProperty;function g(e,t){return T.call(e,t)}function w(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var _=/-(\w)/g,R=w((function(e){return e.replace(_,(function(e,t){return t?t.toUpperCase():""}))})),I=w((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),x=/\B([A-Z])/g,M=w((function(e){return e.replace(x,"-$1").toLowerCase()})),A=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function S(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function k(e,t){for(var n in t)e[n]=t[n];return e}function P(e){for(var t={},n=0;n<e.length;n++)e[n]&&k(t,e[n]);return t}function E(e,t,n){}var C=function(e,t,n){return!1},O=function(e){return e};function D(e,t){if(e===t)return!0;var n=p(e),a=p(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return D(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return D(e[n],t[n])}))}catch(e){return!1}}function $(e,t){for(var n=0;n<e.length;n++)if(D(e[n],t))return n;return-1}function j(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var N="data-server-rendered",V=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:C,isReservedAttr:C,isUnknownElement:C,getTagNamespace:E,parsePlatformTagName:O,mustUseProp:C,async:!0,_lifecycleHooks:F},z=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function B(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var L=new RegExp("[^".concat(z.source,".$_\\d]")),G="__proto__"in{},H="undefined"!=typeof window,Q=H&&window.navigator.userAgent.toLowerCase(),W=Q&&/msie|trident/.test(Q),K=Q&&Q.indexOf("msie 9.0")>0,J=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var Z=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var Y,X=Q&&Q.match(/firefox\/(\d+)/),ee={}.watch,te=!1;if(H)try{var ne={};Object.defineProperty(ne,"passive",{get:function(){te=!0}}),window.addEventListener("test-passive",null,ne)}catch(e){}var ae=function(){return void 0===Y&&(Y=!H&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),Y},ie=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function se(e){return"function"==typeof e&&/native code/.test(e.toString())}var re,oe="undefined"!=typeof Symbol&&se(Symbol)&&"undefined"!=typeof Reflect&&se(Reflect.ownKeys);re="undefined"!=typeof Set&&se(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var pe=null;function de(e){void 0===e&&(e=null),e||pe&&pe._scope.off(),pe=e,e&&e._scope.on()}var le=function(){function e(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),ue=function(e){void 0===e&&(e="");var t=new le;return t.text=e,t.isComment=!0,t};function ye(e){return new le(void 0,void 0,void 0,String(e))}function ce(e){var t=new le(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var me=0,fe=[],he=function(){for(var e=0;e<fe.length;e++){var t=fe[e];t.subs=t.subs.filter((function(e){return e})),t._pending=!1}fe.length=0},be=function(){function e(){this._pending=!1,this.id=me++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,fe.push(this))},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.filter((function(e){return e})),n=0,a=t.length;n<a;n++)t[n].update()},e}();be.target=null;var ve=[];function Te(e){ve.push(e),be.target=e}function ge(){ve.pop(),be.target=ve[ve.length-1]}var we=Array.prototype,_e=Object.create(we);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=we[e];B(_e,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var Re=Object.getOwnPropertyNames(_e),Ie={},xe=!0;function Me(e){xe=e}var Ae={notify:E,depend:E,addSub:E,removeSub:E},Se=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?Ae:new be,this.vmCount=0,B(e,"__ob__",this),t(e)){if(!a)if(G)e.__proto__=_e;else for(var i=0,s=Re.length;i<s;i++)B(e,o=Re[i],_e[o]);n||this.observeArray(e)}else{var r=Object.keys(e);for(i=0;i<r.length;i++){var o;Pe(e,o=r[i],Ie,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)ke(e[t],!1,this.mock)},e}();function ke(e,n,a){return e&&g(e,"__ob__")&&e.__ob__ instanceof Se?e.__ob__:!xe||!a&&ae()||!t(e)&&!l(e)||!Object.isExtensible(e)||e.__v_skip||je(e)||e instanceof le?void 0:new Se(e,n,a)}function Pe(e,n,a,i,s,r){var o=new be,p=Object.getOwnPropertyDescriptor(e,n);if(!p||!1!==p.configurable){var d=p&&p.get,l=p&&p.set;d&&!l||a!==Ie&&2!==arguments.length||(a=e[n]);var u=!s&&ke(a,!1,r);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=d?d.call(e):a;return be.target&&(o.depend(),u&&(u.dep.depend(),t(n)&&Oe(n))),je(n)&&!s?n.value:n},set:function(t){var n,i,p=d?d.call(e):a;if((n=p)===(i=t)?0===n&&1/n!=1/i:n==n||i==i){if(l)l.call(e,t);else{if(d)return;if(!s&&je(p)&&!je(t))return void(p.value=t);a=t}u=!s&&ke(t,!1,r),o.notify()}}}),o}}function Ee(e,n,a){if(!$e(e)){var i=e.__ob__;return t(e)&&u(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&ke(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(Pe(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Ce(e,n){if(t(e)&&u(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||$e(e)||g(e,n)&&(delete e[n],a&&a.dep.notify())}}function Oe(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Oe(n)}function De(e){return function(e,t){$e(e)||ke(e,t,ae())}(e,!0),B(e,"__v_isShallow",!0),e}function $e(e){return!(!e||!e.__v_isReadonly)}function je(e){return!(!e||!0!==e.__v_isRef)}function Ne(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(je(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];je(a)&&!je(e)?a.value=e:t[n]=e}})}var Ve=w((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function Fe(e,n){function a(){var e=a.fns;if(!t(e))return Kt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),s=0;s<i.length;s++)Kt(i[s],null,arguments,n,"v-on handler")}return a.fns=e,a}function qe(e,t,n,i,r,o){var p,d,l,u;for(p in e)d=e[p],l=t[p],u=Ve(p),a(d)||(a(l)?(a(d.fns)&&(d=e[p]=Fe(d,o)),s(u.once)&&(d=e[p]=r(u.name,d,u.capture)),n(u.name,d,u.capture,u.passive,u.params)):d!==l&&(l.fns=d,e[p]=l));for(p in t)a(e[p])&&i((u=Ve(p)).name,t[p],u.capture)}function ze(e,t,n){var r;e instanceof le&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function p(){n.apply(this,arguments),v(r.fns,p)}a(o)?r=Fe([p]):i(o.fns)&&s(o.merged)?(r=o).fns.push(p):r=Fe([o,p]),r.merged=!0,e[t]=r}function Ue(e,t,n,a,s){if(i(t)){if(g(t,n))return e[n]=t[n],s||delete t[n],!0;if(g(t,a))return e[n]=t[a],s||delete t[a],!0}return!1}function Be(e){return r(e)?[ye(e)]:t(e)?Ge(e):void 0}function Le(e){return i(e)&&i(e.text)&&!1===e.isComment}function Ge(e,n){var o,p,d,l,u=[];for(o=0;o<e.length;o++)a(p=e[o])||"boolean"==typeof p||(l=u[d=u.length-1],t(p)?p.length>0&&(Le((p=Ge(p,"".concat(n||"","_").concat(o)))[0])&&Le(l)&&(u[d]=ye(l.text+p[0].text),p.shift()),u.push.apply(u,p)):r(p)?Le(l)?u[d]=ye(l.text+p):""!==p&&u.push(ye(p)):Le(p)&&Le(l)?u[d]=ye(l.text+p.text):(s(e._isVList)&&i(p.tag)&&a(p.key)&&i(n)&&(p.key="__vlist".concat(n,"_").concat(o,"__")),u.push(p)));return u}var He=1,Qe=2;function We(e,n,a,d,l,u){return(t(a)||r(a))&&(l=d,d=a,a=void 0),s(u)&&(l=Qe),function(e,n,a,s,r){if(i(a)&&i(a.__ob__))return ue();if(i(a)&&i(a.is)&&(n=a.is),!n)return ue();var d,l;if(t(s)&&o(s[0])&&((a=a||{}).scopedSlots={default:s[0]},s.length=0),r===Qe?s=Be(s):r===He&&(s=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof n){var u=void 0;l=e.$vnode&&e.$vnode.ns||q.getTagNamespace(n),d=q.isReservedTag(n)?new le(q.parsePlatformTagName(n),a,s,void 0,void 0,e):a&&a.pre||!i(u=Un(e.$options,"components",n))?new le(n,a,s,void 0,void 0,e):Cn(u,a,e,s,n)}else d=Cn(n,a,e,s);return t(d)?d:i(d)?(i(l)&&Ke(d,l),i(a)&&function(e){p(e.style)&&un(e.style),p(e.class)&&un(e.class)}(a),d):ue()}(e,n,a,d,l)}function Ke(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var r=0,o=e.children.length;r<o;r++){var p=e.children[r];i(p.tag)&&(a(p.ns)||s(n)&&"svg"!==p.tag)&&Ke(p,t,n)}}function Je(e,n){var a,s,r,o,d=null;if(t(e)||"string"==typeof e)for(d=new Array(e.length),a=0,s=e.length;a<s;a++)d[a]=n(e[a],a);else if("number"==typeof e)for(d=new Array(e),a=0;a<e;a++)d[a]=n(a+1,a);else if(p(e))if(oe&&e[Symbol.iterator]){d=[];for(var l=e[Symbol.iterator](),u=l.next();!u.done;)d.push(n(u.value,d.length)),u=l.next()}else for(r=Object.keys(e),d=new Array(r.length),a=0,s=r.length;a<s;a++)o=r[a],d[a]=n(e[o],o,a);return i(d)||(d=[]),d._isVList=!0,d}function Ze(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=k(k({},a),n)),i=s(n)||(o(t)?t():t)):i=this.$slots[e]||(o(t)?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function Ye(e){return Un(this.$options,"filters",e)||O}function Xe(e,n){return t(e)?-1===e.indexOf(n):e!==n}function et(e,t,n,a,i){var s=q.keyCodes[t]||n;return i&&a&&!q.keyCodes[t]?Xe(i,a):s?Xe(s,e):a?M(a)!==t:void 0===e}function tt(e,n,a,i,s){if(a&&p(a)){t(a)&&(a=P(a));var r=void 0,o=function(t){if("class"===t||"style"===t||b(t))r=e;else{var o=e.attrs&&e.attrs.type;r=i||q.mustUseProp(n,o,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var p=R(t),d=M(t);p in r||d in r||(r[t]=a[t],s&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var d in a)o(d)}return e}function nt(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||it(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function at(e,t,n){return it(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function it(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&st(e[i],"".concat(n,"_").concat(i),a);else st(e,n,a)}function st(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function rt(e,t){if(t&&l(t)){var n=e.on=e.on?k({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function ot(e,n,a,i){n=n||{$stable:!a};for(var s=0;s<e.length;s++){var r=e[s];t(r)?ot(r,n,a):r&&(r.proxy&&(r.fn.proxy=!0),n[r.key]=r.fn)}return i&&(n.$key=i),n}function pt(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function dt(e,t){return"string"==typeof e?t+e:e}function lt(e){e._o=at,e._n=m,e._s=c,e._l=Je,e._t=Ze,e._q=D,e._i=$,e._m=nt,e._f=Ye,e._k=et,e._b=tt,e._v=ye,e._e=ue,e._u=ot,e._g=rt,e._d=pt,e._p=dt}function ut(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,p=n[o]||(n[o]=[]);"template"===s.tag?p.push.apply(p,s.children||[]):p.push(s)}}for(var d in n)n[d].every(yt)&&delete n[d];return n}function yt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function ct(e){return e.isComment&&e.asyncFactory}function mt(t,n,a,i){var s,r=Object.keys(a).length>0,o=n?!!n.$stable:!r,p=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&i&&i!==e&&p===i.$key&&!r&&!i.$hasNormal)return i;for(var d in s={},n)n[d]&&"$"!==d[0]&&(s[d]=ft(t,a,d,n[d]))}else s={};for(var l in a)l in s||(s[l]=ht(a,l));return n&&Object.isExtensible(n)&&(n._normalized=s),B(s,"$stable",o),B(s,"$key",p),B(s,"$hasNormal",r),s}function ft(e,n,a,i){var s=function(){var n=pe;de(e);var a=arguments.length?i.apply(null,arguments):i({}),s=(a=a&&"object"==typeof a&&!t(a)?[a]:Be(a))&&a[0];return de(n),a&&(!s||1===a.length&&s.isComment&&!ct(s))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:s,enumerable:!0,configurable:!0}),s}function ht(e,t){return function(){return e[t]}}function bt(e,t,n,a,i){var s=!1;for(var r in t)r in e?t[r]!==n[r]&&(s=!0):(s=!0,vt(e,r,a,i));for(var r in e)r in t||(s=!0,delete e[r]);return s}function vt(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function Tt(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var gt,wt=null;function _t(e,t){return(e.__esModule||oe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),p(e)?t.extend(e):e}function Rt(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||ct(a)))return a}}function It(e,t){gt.$on(e,t)}function xt(e,t){gt.$off(e,t)}function Mt(e,t){var n=gt;return function a(){null!==t.apply(null,arguments)&&n.$off(e,a)}}function At(e,t,n){gt=e,qe(t,n||{},It,xt,Mt,e),gt=void 0}var St=null;function kt(e){var t=St;return St=e,function(){St=t}}function Pt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function Et(e,t){if(t){if(e._directInactive=!1,Pt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)Et(e.$children[n]);Ot(e,"activated")}}function Ct(e,t){if(!(t&&(e._directInactive=!0,Pt(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)Ct(e.$children[n]);Ot(e,"deactivated")}}function Ot(e,t,n,a){void 0===a&&(a=!0),Te();var i=pe;a&&de(e);var s=e.$options[t],r="".concat(t," hook");if(s)for(var o=0,p=s.length;o<p;o++)Kt(s[o],e,n||null,e,r);e._hasHookEvent&&e.$emit("hook:"+t),a&&de(i),ge()}var Dt=[],$t=[],jt={},Nt=!1,Vt=!1,Ft=0,qt=0,zt=Date.now;if(H&&!W){var Ut=window.performance;Ut&&"function"==typeof Ut.now&&zt()>document.createEvent("Event").timeStamp&&(zt=function(){return Ut.now()})}var Bt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function Lt(){var e,t;for(qt=zt(),Vt=!0,Dt.sort(Bt),Ft=0;Ft<Dt.length;Ft++)(e=Dt[Ft]).before&&e.before(),t=e.id,jt[t]=null,e.run();var n=$t.slice(),a=Dt.slice();Ft=Dt.length=$t.length=0,jt={},Nt=Vt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,Et(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&Ot(a,"updated")}}(a),he(),ie&&q.devtools&&ie.emit("flush")}var Gt,Ht="watcher";"".concat(Ht," callback"),"".concat(Ht," getter"),"".concat(Ht," cleanup");var Qt=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Gt,!e&&Gt&&(this.index=(Gt.scopes||(Gt.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=Gt;try{return Gt=this,e()}finally{Gt=t}}},e.prototype.on=function(){Gt=this},e.prototype.off=function(){Gt=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},e}();function Wt(e,t,n){Te();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Jt(e,a,"errorCaptured hook")}}Jt(e,t,n)}finally{ge()}}function Kt(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&y(s)&&!s._handled&&(s.catch((function(e){return Wt(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){Wt(e,a,i)}return s}function Jt(e,t,n){if(q.errorHandler)try{return q.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Zt(t)}Zt(e)}function Zt(e,t,n){if(!H||"undefined"==typeof console)throw e;console.error(e)}var Yt,Xt=!1,en=[],tn=!1;function nn(){tn=!1;var e=en.slice(0);en.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&se(Promise)){var an=Promise.resolve();Yt=function(){an.then(nn),Z&&setTimeout(E)},Xt=!0}else if(W||"undefined"==typeof MutationObserver||!se(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Yt="undefined"!=typeof setImmediate&&se(setImmediate)?function(){setImmediate(nn)}:function(){setTimeout(nn,0)};else{var sn=1,rn=new MutationObserver(nn),on=document.createTextNode(String(sn));rn.observe(on,{characterData:!0}),Yt=function(){sn=(sn+1)%2,on.data=String(sn)},Xt=!0}function pn(e,t){var n;if(en.push((function(){if(e)try{e.call(t)}catch(e){Wt(e,t,"nextTick")}else n&&n(t)})),tn||(tn=!0,Yt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function dn(e){return function(t,n){if(void 0===n&&(n=pe),n)return function(e,t,n){var a=e.$options;a[t]=Vn(a[t],n)}(n,e,t)}}dn("beforeMount"),dn("mounted"),dn("beforeUpdate"),dn("updated"),dn("beforeDestroy"),dn("destroyed"),dn("activated"),dn("deactivated"),dn("serverPrefetch"),dn("renderTracked"),dn("renderTriggered"),dn("errorCaptured");var ln=new re;function un(e){return yn(e,ln),ln.clear(),e}function yn(e,n){var a,i,s=t(e);if(!(!s&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof le)){if(e.__ob__){var r=e.__ob__.dep.id;if(n.has(r))return;n.add(r)}if(s)for(a=e.length;a--;)yn(e[a],n);else if(je(e))yn(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)yn(e[i[a]],n)}}var cn=0,mn=function(){function e(e,t,n,a,i){var s;void 0===(s=Gt&&!Gt._vm?Gt:e?e._scope:void 0)&&(s=Gt),s&&s.active&&s.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++cn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new re,this.newDepIds=new re,this.expression="",o(t)?this.getter=t:(this.getter=function(e){if(!L.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=E)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;Te(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Wt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&un(e),ge(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==jt[t]&&(e!==be.target||!e.noRecurse)){if(jt[t]=!0,Vt){for(var n=Dt.length-1;n>Ft&&Dt[n].id>e.id;)n--;Dt.splice(n+1,0,e)}else Dt.push(e);Nt||(Nt=!0,pn(Lt))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||p(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Kt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&v(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),fn={enumerable:!0,configurable:!0,get:E,set:E};function hn(e,t,n){fn.get=function(){return this[t][n]},fn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,fn)}function bn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=De({}),i=e.$options._propKeys=[];!e.$parent||Me(!1);var s=function(s){i.push(s);var r=Bn(s,t,n,e);Pe(a,s,r),s in e||hn(e,"_props",s)};for(var r in t)s(r);Me(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};B(n,"_v_attr_proxy",!0),bt(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||bt(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||Tt(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:A(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return Ne(t,e,n)}))}}}(t);de(t),Te();var s=Kt(a,null,[t._props||De({}),i],t,"setup");if(ge(),de(),o(s))n.render=s;else if(p(s))if(t._setupState=s,s.__sfc){var r=t._setupProxy={};for(var d in s)"__sfc"!==d&&Ne(r,s,d)}else for(var d in s)U(d)||Ne(t,s,d)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?E:A(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;l(t=e._data=o(t)?function(e,t){Te();try{return e.call(t,t)}catch(e){return Wt(e,t,"data()"),{}}finally{ge()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&g(a,s)||U(s)||hn(e,"_data",s)}var r=ke(t);r&&r.vmCount++}(n);else{var i=ke(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ae();for(var i in t){var s=t[i],r=o(s)?s:s.get;a||(n[i]=new mn(e,r||E,E,vn)),i in e||Tn(e,i,s)}}(n,a.computed),a.watch&&a.watch!==ee&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var s=0;s<i.length;s++)_n(e,a,i[s]);else _n(e,a,i)}}(n,a.watch)}var vn={lazy:!0};function Tn(e,t,n){var a=!ae();o(n)?(fn.get=a?gn(t):wn(n),fn.set=E):(fn.get=n.get?a&&!1!==n.cache?gn(t):wn(n.get):E,fn.set=n.set||E),Object.defineProperty(e,t,fn)}function gn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),be.target&&t.depend(),t.value}}function wn(e){return function(){return e.call(this,this)}}function _n(e,t,n,a){return l(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function Rn(e,t){if(e){for(var n=Object.create(null),a=oe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){var r=e[s].from;if(r in t._provided)n[s]=t._provided[r];else if("default"in e[s]){var p=e[s].default;n[s]=o(p)?p.call(t):p}}}return n}}var In=0;function xn(e){var t=e.options;if(e.super){var n=xn(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&k(e.extendOptions,a),(t=e.options=zn(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Mn(n,a,i,r,o){var p,d=this,l=o.options;g(r,"_uid")?(p=Object.create(r))._original=r:(p=r,r=r._original);var u=s(l._compiled),y=!u;this.data=n,this.props=a,this.children=i,this.parent=r,this.listeners=n.on||e,this.injections=Rn(l.inject,r),this.slots=function(){return d.$slots||mt(r,n.scopedSlots,d.$slots=ut(i,r)),d.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return mt(r,n.scopedSlots,this.slots())}}),u&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=mt(r,n.scopedSlots,this.$slots)),l._scopeId?this._c=function(e,n,a,i){var s=We(p,e,n,a,i,y);return s&&!t(s)&&(s.fnScopeId=l._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return We(p,e,t,n,a,y)}}function An(e,t,n,a,i){var s=ce(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Sn(e,t){for(var n in t)e[R(n)]=t[n]}function kn(e){return e.name||e.__name||e._componentTag}lt(Mn.prototype);var Pn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Pn.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,St)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,s){var r=i.data.scopedSlots,o=t.$scopedSlots,p=!!(r&&!r.$stable||o!==e&&!o.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),d=!!(s||t.$options._renderChildren||p),l=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=s;var u=i.data.attrs||e;t._attrsProxy&&bt(t._attrsProxy,u,l.data&&l.data.attrs||e,t,"$attrs")&&(d=!0),t.$attrs=u,a=a||e;var y=t.$options._parentListeners;if(t._listenersProxy&&bt(t._listenersProxy,a,y||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,At(t,a,y),n&&t.$options.props){Me(!1);for(var c=t._props,m=t.$options._propKeys||[],f=0;f<m.length;f++){var h=m[f],b=t.$options.props;c[h]=Bn(h,b,n,t)}Me(!0),t.$options.propsData=n}d&&(t.$slots=ut(s,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,Ot(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,$t.push(t)):Et(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?Ct(t,!0):t.$destroy())}},En=Object.keys(Pn);function Cn(n,r,o,d,l){if(!a(n)){var u=o.$options._base;if(p(n)&&(n=u.extend(n)),"function"==typeof n){var c;if(a(n.cid)&&(n=function(e,t){if(s(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=wt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),s(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var r=e.owners=[n],o=!0,d=null,l=null;n.$on("hook:destroyed",(function(){return v(r,n)}));var u=function(e){for(var t=0,n=r.length;t<n;t++)r[t].$forceUpdate();e&&(r.length=0,null!==d&&(clearTimeout(d),d=null),null!==l&&(clearTimeout(l),l=null))},c=j((function(n){e.resolved=_t(n,t),o?r.length=0:u(!0)})),m=j((function(t){i(e.errorComp)&&(e.error=!0,u(!0))})),f=e(c,m);return p(f)&&(y(f)?a(e.resolved)&&f.then(c,m):y(f.component)&&(f.component.then(c,m),i(f.error)&&(e.errorComp=_t(f.error,t)),i(f.loading)&&(e.loadingComp=_t(f.loading,t),0===f.delay?e.loading=!0:d=setTimeout((function(){d=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,u(!1))}),f.delay||200)),i(f.timeout)&&(l=setTimeout((function(){l=null,a(e.resolved)&&m(null)}),f.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(c=n,u),void 0===n))return function(e,t,n,a,i){var s=ue();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(c,r,o,d,l);r=r||{},xn(n),i(r.model)&&function(e,n){var a=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var r=n.on||(n.on={}),o=r[s],p=n.model.callback;i(o)?(t(o)?-1===o.indexOf(p):o!==p)&&(r[s]=[p].concat(o)):r[s]=p}(n.options,r);var m=function(e,t,n){var s=t.options.props;if(!a(s)){var r={},o=e.attrs,p=e.props;if(i(o)||i(p))for(var d in s){var l=M(d);Ue(r,p,d,l,!0)||Ue(r,o,d,l,!1)}return r}}(r,n);if(s(n.options.functional))return function(n,a,s,r,o){var p=n.options,d={},l=p.props;if(i(l))for(var u in l)d[u]=Bn(u,l,a||e);else i(s.attrs)&&Sn(d,s.attrs),i(s.props)&&Sn(d,s.props);var y=new Mn(s,d,o,r,n),c=p.render.call(null,y._c,y);if(c instanceof le)return An(c,s,y.parent,p);if(t(c)){for(var m=Be(c)||[],f=new Array(m.length),h=0;h<m.length;h++)f[h]=An(m[h],s,y.parent,p);return f}}(n,m,r,o,d);var f=r.on;if(r.on=r.nativeOn,s(n.options.abstract)){var h=r.slot;r={},h&&(r.slot=h)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<En.length;n++){var a=En[n],i=t[a],s=Pn[a];i===s||i&&i._merged||(t[a]=i?On(s,i):s)}}(r);var b=kn(n.options)||l;return new le("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:m,listeners:f,tag:l,children:d},c)}}}function On(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var Dn=E,$n=q.optionMergeStrategies;function jn(e,t,n){if(void 0===n&&(n=!0),!t)return e;for(var a,i,s,r=oe?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++)"__ob__"!==(a=r[o])&&(i=e[a],s=t[a],n&&g(e,a)?i!==s&&l(i)&&l(s)&&jn(i,s):Ee(e,a,s));return e}function Nn(e,t,n){return n?function(){var a=o(t)?t.call(n,n):t,i=o(e)?e.call(n,n):e;return a?jn(a,i):i}:t?e?function(){return jn(o(t)?t.call(this,this):t,o(e)?e.call(this,this):e)}:t:e}function Vn(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function Fn(e,t,n,a){var i=Object.create(e||null);return t?k(i,t):i}$n.data=function(e,t,n){return n?Nn(e,t,n):t&&"function"!=typeof t?e:Nn(e,t)},F.forEach((function(e){$n[e]=Vn})),V.forEach((function(e){$n[e+"s"]=Fn})),$n.watch=function(e,n,a,i){if(e===ee&&(e=void 0),n===ee&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var s={};for(var r in k(s,e),n){var o=s[r],p=n[r];o&&!t(o)&&(o=[o]),s[r]=o?o.concat(p):t(p)?p:[p]}return s},$n.props=$n.methods=$n.inject=$n.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return k(i,e),t&&k(i,t),i},$n.provide=function(e,t){return e?function(){var n=Object.create(null);return jn(n,o(e)?e.call(this):e),t&&jn(n,o(t)?t.call(this):t,!1),n}:t};var qn=function(e,t){return void 0===t?e:t};function zn(e,n,a){if(o(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,s,r={};if(t(a))for(i=a.length;i--;)"string"==typeof(s=a[i])&&(r[R(s)]={type:null});else if(l(a))for(var o in a)s=a[o],r[R(o)]=l(s)?s:{type:s};e.props=r}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var s=0;s<a.length;s++)i[a[s]]={from:a[s]};else if(l(a))for(var r in a){var o=a[r];i[r]=l(o)?k({from:r},o):{from:o}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];o(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=zn(e,n.extends,a)),n.mixins))for(var i=0,s=n.mixins.length;i<s;i++)e=zn(e,n.mixins[i],a);var r,p={};for(r in e)d(r);for(r in n)g(e,r)||d(r);function d(t){var i=$n[t]||qn;p[t]=i(e[t],n[t],a,t)}return p}function Un(e,t,n,a){if("string"==typeof n){var i=e[t];if(g(i,n))return i[n];var s=R(n);if(g(i,s))return i[s];var r=I(s);return g(i,r)?i[r]:i[n]||i[s]||i[r]}}function Bn(e,t,n,a){var i=t[e],s=!g(n,e),r=n[e],p=Qn(Boolean,i.type);if(p>-1)if(s&&!g(i,"default"))r=!1;else if(""===r||r===M(e)){var d=Qn(String,i.type);(d<0||p<d)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(g(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:o(a)&&"Function"!==Gn(t.type)?a.call(e):a}}(a,i,e);var l=xe;Me(!0),ke(r),Me(l)}return r}var Ln=/^\s*function (\w+)/;function Gn(e){var t=e&&e.toString().match(Ln);return t?t[1]:""}function Hn(e,t){return Gn(e)===Gn(t)}function Qn(e,n){if(!t(n))return Hn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Hn(n[a],e))return a;return-1}function Wn(e){this._init(e)}function Kn(e){return e&&(kn(e.Ctor.options)||e.tag)}function Jn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==d.call(a))&&e.test(n));var a}function Zn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var r=n[s];if(r){var o=r.name;o&&!t(o)&&Yn(n,s,a,i)}}}function Yn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,v(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=In++,n._isVue=!0,n.__v_skip=!0,n._scope=new Qt(!0),n._scope._vm=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=zn(xn(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&At(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=ut(n._renderChildren,i),t.$scopedSlots=a?mt(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return We(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return We(t,e,n,a,i,!0)};var s=a&&a.data;Pe(t,"$attrs",s&&s.attrs||e,null,!0),Pe(t,"$listeners",n._parentListeners||e,null,!0)}(n),Ot(n,"beforeCreate",void 0,!1),function(e){var t=Rn(e.$options.inject,e);t&&(Me(!1),Object.keys(t).forEach((function(n){Pe(e,n,t[n])})),Me(!0))}(n),bn(n),function(e){var t=e.$options.provide;if(t){var n=o(t)?t.call(e):t;if(!p(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=oe?Reflect.ownKeys(n):Object.keys(n),s=0;s<i.length;s++){var r=i[s];Object.defineProperty(a,r,Object.getOwnPropertyDescriptor(n,r))}}}(n),Ot(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Wn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Ee,e.prototype.$delete=Ce,e.prototype.$watch=function(e,t,n){var a=this;if(l(t))return _n(a,e,t,n);(n=n||{}).user=!0;var i=new mn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'.concat(i.expression,'"');Te(),Kt(t,a,[i.value],a,s),ge()}return function(){i.teardown()}}}(Wn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var s=0,r=e.length;s<r;s++)i.$on(e[s],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,s=e.length;i<s;i++)a.$off(e[i],n);return a}var r,o=a._events[e];if(!o)return a;if(!n)return a._events[e]=null,a;for(var p=o.length;p--;)if((r=o[p])===n||r.fn===n){o.splice(p,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?S(n):n;for(var a=S(arguments,1),i='event handler for "'.concat(e,'"'),s=0,r=n.length;s<r;s++)Kt(n[s],t,a,t,i)}return t}}(Wn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=kt(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var r=n;r&&r.$vnode&&r.$parent&&r.$vnode===r.$parent._vnode;)r.$parent.$el=r.$el,r=r.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Ot(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||v(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Ot(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Wn),function(e){lt(e.prototype),e.prototype.$nextTick=function(e){return pn(e,this)},e.prototype._render=function(){var e,n=this,a=n.$options,i=a.render,s=a._parentVnode;s&&n._isMounted&&(n.$scopedSlots=mt(n.$parent,s.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&Tt(n._slotsProxy,n.$scopedSlots)),n.$vnode=s;try{de(n),wt=n,e=i.call(n._renderProxy,n.$createElement)}catch(t){Wt(t,n,"render"),e=n._vnode}finally{wt=null,de()}return t(e)&&1===e.length&&(e=e[0]),e instanceof le||(e=ue()),e.parent=s,e}}(Wn);var Xn=[String,RegExp,Array],ea={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xn,exclude:Xn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:Kn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&Yn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Yn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Zn(e,(function(e){return Jn(t,e)}))})),this.$watch("exclude",(function(t){Zn(e,(function(e){return!Jn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=Rt(e),n=t&&t.componentOptions;if(n){var a=Kn(n),i=this.include,s=this.exclude;if(i&&(!a||!Jn(i,a))||s&&a&&Jn(s,a))return t;var r=this.cache,o=this.keys,p=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;r[p]?(t.componentInstance=r[p].componentInstance,v(o,p),o.push(p)):(this.vnodeToCache=t,this.keyToCache=p),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return q}};Object.defineProperty(e,"config",t),e.util={warn:Dn,extend:k,mergeOptions:zn,defineReactive:Pe},e.set=Ee,e.delete=Ce,e.nextTick=pn,e.observable=function(e){return ke(e),e},e.options=Object.create(null),V.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,k(e.options.components,ea),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=S(arguments,1);return n.unshift(this),o(e.install)?e.install.apply(e,n):o(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=zn(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=kn(e)||kn(n.options),r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=zn(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)hn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)Tn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,V.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=k({},r.options),i[a]=r,r}}(e),function(e){V.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&l(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&o(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Wn),Object.defineProperty(Wn.prototype,"$isServer",{get:ae}),Object.defineProperty(Wn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wn,"FunctionalRenderContext",{value:Mn}),Wn.version="2.7.14";var ta=f("style,class"),na=f("input,textarea,option,select,progress"),aa=function(e,t,n){return"value"===n&&na(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},ia=f("contenteditable,draggable,spellcheck"),sa=f("events,caret,typing,plaintext-only"),ra=function(e,t){return ua(t)||"false"===t?"false":"contenteditable"===e&&sa(t)?t:"true"},oa=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),pa="http://www.w3.org/1999/xlink",da=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},la=function(e){return da(e)?e.slice(6,e.length):""},ua=function(e){return null==e||!1===e};function ya(e,t){return{staticClass:ca(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function ca(e,t){return e?t?e+" "+t:e:t||""}function ma(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,s=e.length;a<s;a++)i(t=ma(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):p(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var fa={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ba=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),va=function(e){return ha(e)||ba(e)};function Ta(e){return ba(e)?"svg":"math"===e?"math":void 0}var ga=Object.create(null),wa=f("text,number,password,search,email,tel,url");function _a(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var Ra=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(fa[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),Ia={create:function(e,t){xa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(xa(e,!0),xa(t))},destroy:function(e){xa(e,!0)}};function xa(e,n){var a=e.data.ref;if(i(a)){var s=e.context,r=e.componentInstance||e.elm,p=n?null:r,d=n?void 0:r;if(o(a))Kt(a,s,[p],s,"template ref function");else{var l=e.data.refInFor,u="string"==typeof a||"number"==typeof a,y=je(a),c=s.$refs;if(u||y)if(l){var m=u?c[a]:a.value;n?t(m)&&v(m,r):t(m)?m.includes(r)||m.push(r):u?(c[a]=[r],Ma(s,a,c[a])):a.value=[r]}else if(u){if(n&&c[a]!==r)return;c[a]=d,Ma(s,a,p)}else if(y){if(n&&a.value!==r)return;a.value=p}}}}function Ma(e,t,n){var a=e._setupState;a&&g(a,t)&&(je(a[t])?a[t].value=n:a[t]=n)}var Aa=new le("",{},[]),Sa=["create","activate","update","remove","destroy"];function ka(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,s=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===s||wa(a)&&wa(s)}(e,t)||s(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function Pa(e,t,n){var a,s,r={};for(a=t;a<=n;++a)i(s=e[a].key)&&(r[s]=a);return r}var Ea={create:Ca,update:Ca,destroy:function(e){Ca(e,Aa)}};function Ca(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===Aa,r=t===Aa,o=Da(e.data.directives,e.context),p=Da(t.data.directives,t.context),d=[],l=[];for(n in p)a=o[n],i=p[n],a?(i.oldValue=a.value,i.oldArg=a.arg,ja(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(ja(i,"bind",t,e),i.def&&i.def.inserted&&d.push(i));if(d.length){var u=function(){for(var n=0;n<d.length;n++)ja(d[n],"inserted",t,e)};s?ze(t,"insert",u):u()}if(l.length&&ze(t,"postpatch",(function(){for(var n=0;n<l.length;n++)ja(l[n],"componentUpdated",t,e)})),!s)for(n in o)p[n]||ja(o[n],"unbind",e,e,r)}(e,t)}var Oa=Object.create(null);function Da(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Oa),i[$a(a)]=a,t._setupState&&t._setupState.__sfc){var s=a.def||Un(t,"_setupState","v-"+a.name);a.def="function"==typeof s?{bind:s,update:s}:s}a.def=a.def||Un(t.$options,"directives",a.name)}return i}function $a(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function ja(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){Wt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Na=[Ia,Ea];function Va(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var r,o,p=t.elm,d=e.data.attrs||{},l=t.data.attrs||{};for(r in(i(l.__ob__)||s(l._v_attr_proxy))&&(l=t.data.attrs=k({},l)),l)o=l[r],d[r]!==o&&Fa(p,r,o,t.data.pre);for(r in(W||J)&&l.value!==d.value&&Fa(p,"value",l.value),d)a(l[r])&&(da(r)?p.removeAttributeNS(pa,la(r)):ia(r)||p.removeAttribute(r))}}function Fa(e,t,n,a){a||e.tagName.indexOf("-")>-1?qa(e,t,n):oa(t)?ua(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):ia(t)?e.setAttribute(t,ra(t,n)):da(t)?ua(n)?e.removeAttributeNS(pa,la(t)):e.setAttributeNS(pa,t,n):qa(e,t,n)}function qa(e,t,n){if(ua(n))e.removeAttribute(t);else{if(W&&!K&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var za={create:Va,update:Va};function Ua(e,t){var n=t.elm,s=t.data,r=e.data;if(!(a(s.staticClass)&&a(s.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ya(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=ya(t,n.data));return s=t.staticClass,r=t.class,i(s)||i(r)?ca(s,ma(r)):"";var s,r}(t),p=n._transitionClasses;i(p)&&(o=ca(o,ma(p))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Ba,La,Ga,Ha,Qa,Wa,Ka={create:Ua,update:Ua},Ja=/[\w).+\-_$\]]/;function Za(e){var t,n,a,i,s,r=!1,o=!1,p=!1,d=!1,l=0,u=0,y=0,c=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(p)96===t&&92!==n&&(p=!1);else if(d)47===t&&92!==n&&(d=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||l||u||y){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:p=!0;break;case 40:y++;break;case 41:y--;break;case 91:u++;break;case 93:u--;break;case 123:l++;break;case 125:l--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&Ja.test(f)||(d=!0)}}else void 0===i?(c=a+1,i=e.slice(0,a).trim()):h();function h(){(s||(s=[])).push(e.slice(c,a).trim()),c=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==c&&h(),s)for(a=0;a<s.length;a++)i=Ya(i,s[a]);return i}function Ya(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function Xa(e,t){console.error("[Vue compiler]: ".concat(e))}function ei(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function ti(e,t,n,a,i){(e.props||(e.props=[])).push(li({name:t,value:n,dynamic:i},a)),e.plain=!1}function ni(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(li({name:t,value:n,dynamic:i},a)),e.plain=!1}function ai(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(li({name:t,value:n},a))}function ii(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push(li({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function si(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function ri(t,n,a,i,s,r,o,p){var d;(i=i||e).right?p?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(p?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=si("!",n,p)),i.once&&(delete i.once,n=si("~",n,p)),i.passive&&(delete i.passive,n=si("&",n,p)),i.native?(delete i.native,d=t.nativeEvents||(t.nativeEvents={})):d=t.events||(t.events={});var l=li({value:a.trim(),dynamic:p},o);i!==e&&(l.modifiers=i);var u=d[n];Array.isArray(u)?s?u.unshift(l):u.push(l):d[n]=u?s?[l,u]:[u,l]:l,t.plain=!1}function oi(e,t,n){var a=pi(e,":"+t)||pi(e,"v-bind:"+t);if(null!=a)return Za(a);if(!1!==n){var i=pi(e,t);if(null!=i)return JSON.stringify(i)}}function pi(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function di(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function li(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function ui(e,t,n){var a=n||{},i=a.number,s="$$v",r=s;a.trim&&(r="(typeof ".concat(s," === 'string'")+"? ".concat(s,".trim()")+": ".concat(s,")")),i&&(r="_n(".concat(r,")"));var o=yi(t,r);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(s,") {").concat(o,"}")}}function yi(e,t){var n=function(e){if(e=e.trim(),Ba=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Ba-1)return(Ha=e.lastIndexOf("."))>-1?{exp:e.slice(0,Ha),key:'"'+e.slice(Ha+1)+'"'}:{exp:e,key:null};for(La=e,Ha=Qa=Wa=0;!mi();)fi(Ga=ci())?bi(Ga):91===Ga&&hi(Ga);return{exp:e.slice(0,Qa),key:e.slice(Qa+1,Wa)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function ci(){return La.charCodeAt(++Ha)}function mi(){return Ha>=Ba}function fi(e){return 34===e||39===e}function hi(e){var t=1;for(Qa=Ha;!mi();)if(fi(e=ci()))bi(e);else if(91===e&&t++,93===e&&t--,0===t){Wa=Ha;break}}function bi(e){for(var t=e;!mi()&&(e=ci())!==t;);}var vi,Ti="__r",gi="__c";function wi(e,t,n){var a=vi;return function i(){null!==t.apply(null,arguments)&&Ii(e,i,n,a)}}var _i=Xt&&!(X&&Number(X[1])<=53);function Ri(e,t,n,a){if(_i){var i=qt,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}vi.addEventListener(e,t,te?{capture:n,passive:a}:n)}function Ii(e,t,n,a){(a||vi).removeEventListener(e,t._wrapper||t,n)}function xi(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},s=e.data.on||{};vi=t.elm||e.elm,function(e){if(i(e[Ti])){var t=W?"change":"input";e[t]=[].concat(e[Ti],e[t]||[]),delete e[Ti]}i(e[gi])&&(e.change=[].concat(e[gi],e.change||[]),delete e[gi])}(n),qe(n,s,Ri,Ii,wi,t.context),vi=void 0}}var Mi,Ai={create:xi,update:xi,destroy:function(e){return xi(e,Aa)}};function Si(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,r,o=t.elm,p=e.data.domProps||{},d=t.data.domProps||{};for(n in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=t.data.domProps=k({},d)),p)n in d||(o[n]="");for(n in d){if(r=d[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),r===p[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=r;var l=a(r)?"":String(r);ki(o,l)&&(o.value=l)}else if("innerHTML"===n&&ba(o.tagName)&&a(o.innerHTML)){(Mi=Mi||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Mi.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(r!==p[n])try{o[n]=r}catch(e){}}}}function ki(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return m(n)!==m(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Pi={create:Si,update:Si},Ei=w((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function Ci(e){var t=Oi(e.style);return e.staticStyle?k(e.staticStyle,t):t}function Oi(e){return Array.isArray(e)?P(e):"string"==typeof e?Ei(e):e}var Di,$i=/^--/,ji=/\s*!important$/,Ni=function(e,t,n){if($i.test(t))e.style.setProperty(t,n);else if(ji.test(n))e.style.setProperty(M(t),n.replace(ji,""),"important");else{var a=Fi(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},Vi=["Webkit","Moz","ms"],Fi=w((function(e){if(Di=Di||document.createElement("div").style,"filter"!==(e=R(e))&&e in Di)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Vi.length;n++){var a=Vi[n]+t;if(a in Di)return a}}));function qi(e,t){var n=t.data,s=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(s.staticStyle)&&a(s.style))){var r,o,p=t.elm,d=s.staticStyle,l=s.normalizedStyle||s.style||{},u=d||l,y=Oi(t.data.style)||{};t.data.normalizedStyle=i(y.__ob__)?k({},y):y;var c=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=Ci(i.data))&&k(a,n);(n=Ci(e.data))&&k(a,n);for(var s=e;s=s.parent;)s.data&&(n=Ci(s.data))&&k(a,n);return a}(t);for(o in u)a(c[o])&&Ni(p,o,"");for(o in c)(r=c[o])!==u[o]&&Ni(p,o,null==r?"":r)}}var zi={create:qi,update:qi},Ui=/\s+/;function Bi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function Li(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Gi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&k(t,Hi(e.name||"v")),k(t,e),t}return"string"==typeof e?Hi(e):void 0}}var Hi=w((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),Qi=H&&!K,Wi="transition",Ki="animation",Ji="transition",Zi="transitionend",Yi="animation",Xi="animationend";Qi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ji="WebkitTransition",Zi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Yi="WebkitAnimation",Xi="webkitAnimationEnd"));var es=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function ts(e){es((function(){es(e)}))}function ns(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Bi(e,t))}function as(e,t){e._transitionClasses&&v(e._transitionClasses,t),Li(e,t)}function is(e,t,n){var a=rs(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===Wi?Zi:Xi,p=0,d=function(){e.removeEventListener(o,l),n()},l=function(t){t.target===e&&++p>=r&&d()};setTimeout((function(){p<r&&d()}),s+1),e.addEventListener(o,l)}var ss=/\b(transform|all)(,|$)/;function rs(e,t){var n,a=window.getComputedStyle(e),i=(a[Ji+"Delay"]||"").split(", "),s=(a[Ji+"Duration"]||"").split(", "),r=os(i,s),o=(a[Yi+"Delay"]||"").split(", "),p=(a[Yi+"Duration"]||"").split(", "),d=os(o,p),l=0,u=0;return t===Wi?r>0&&(n=Wi,l=r,u=s.length):t===Ki?d>0&&(n=Ki,l=d,u=p.length):u=(n=(l=Math.max(r,d))>0?r>d?Wi:Ki:null)?n===Wi?s.length:p.length:0,{type:n,timeout:l,propCount:u,hasTransform:n===Wi&&ss.test(a[Ji+"Property"])}}function os(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return ps(t)+ps(e[n])})))}function ps(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function ds(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var s=Gi(e.data.transition);if(!a(s)&&!i(n._enterCb)&&1===n.nodeType){for(var r=s.css,d=s.type,l=s.enterClass,u=s.enterToClass,y=s.enterActiveClass,c=s.appearClass,f=s.appearToClass,h=s.appearActiveClass,b=s.beforeEnter,v=s.enter,T=s.afterEnter,g=s.enterCancelled,w=s.beforeAppear,_=s.appear,R=s.afterAppear,I=s.appearCancelled,x=s.duration,M=St,A=St.$vnode;A&&A.parent;)M=A.context,A=A.parent;var S=!M._isMounted||!e.isRootInsert;if(!S||_||""===_){var k=S&&c?c:l,P=S&&h?h:y,E=S&&f?f:u,C=S&&w||b,O=S&&o(_)?_:v,D=S&&R||T,$=S&&I||g,N=m(p(x)?x.enter:x),V=!1!==r&&!K,F=ys(O),q=n._enterCb=j((function(){V&&(as(n,E),as(n,P)),q.cancelled?(V&&as(n,k),$&&$(n)):D&&D(n),n._enterCb=null}));e.data.show||ze(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),O&&O(n,q)})),C&&C(n),V&&(ns(n,k),ns(n,P),ts((function(){as(n,k),q.cancelled||(ns(n,E),F||(us(N)?setTimeout(q,N):is(n,d,q)))}))),e.data.show&&(t&&t(),O&&O(n,q)),V||F||q()}}}function ls(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var s=Gi(e.data.transition);if(a(s)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var r=s.css,o=s.type,d=s.leaveClass,l=s.leaveToClass,u=s.leaveActiveClass,y=s.beforeLeave,c=s.leave,f=s.afterLeave,h=s.leaveCancelled,b=s.delayLeave,v=s.duration,T=!1!==r&&!K,g=ys(c),w=m(p(v)?v.leave:v),_=n._leaveCb=j((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),T&&(as(n,l),as(n,u)),_.cancelled?(T&&as(n,d),h&&h(n)):(t(),f&&f(n)),n._leaveCb=null}));b?b(R):R()}function R(){_.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),y&&y(n),T&&(ns(n,d),ns(n,u),ts((function(){as(n,d),_.cancelled||(ns(n,l),g||(us(w)?setTimeout(_,w):is(n,o,_)))}))),c&&c(n,_),T||g||_())}}function us(e){return"number"==typeof e&&!isNaN(e)}function ys(e){if(a(e))return!1;var t=e.fns;return i(t)?ys(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function cs(e,t){!0!==t.data.show&&ds(t)}var ms=function(e){var n,o,p={},d=e.modules,l=e.nodeOps;for(n=0;n<Sa.length;++n)for(p[Sa[n]]=[],o=0;o<d.length;++o)i(d[o][Sa[n]])&&p[Sa[n]].push(d[o][Sa[n]]);function u(e){var t=l.parentNode(e);i(t)&&l.removeChild(t,e)}function y(e,t,n,a,r,o,d){if(i(e.elm)&&i(o)&&(e=o[d]=ce(e)),e.isRootInsert=!r,!function(e,t,n,a){var r=e.data;if(i(r)){var o=i(e.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(e,!1),i(e.componentInstance))return c(e,t),m(n,e.elm,a),s(o)&&function(e,t,n,a){for(var s,r=e;r.componentInstance;)if(i(s=(r=r.componentInstance._vnode).data)&&i(s=s.transition)){for(s=0;s<p.activate.length;++s)p.activate[s](Aa,r);t.push(r);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var u=e.data,y=e.children,f=e.tag;i(f)?(e.elm=e.ns?l.createElementNS(e.ns,f):l.createElement(f,e),T(e),h(e,y,t),i(u)&&v(e,t),m(n,e.elm,a)):s(e.isComment)?(e.elm=l.createComment(e.text),m(n,e.elm,a)):(e.elm=l.createTextNode(e.text),m(n,e.elm,a))}}function c(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,b(e)?(v(e,t),T(e)):(xa(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?l.parentNode(n)===e&&l.insertBefore(e,t,n):l.appendChild(e,t))}function h(e,n,a){if(t(n))for(var i=0;i<n.length;++i)y(n[i],a,e.elm,null,!0,n,i);else r(e.text)&&l.appendChild(e.elm,l.createTextNode(String(e.text)))}function b(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function v(e,t){for(var a=0;a<p.create.length;++a)p.create[a](Aa,e);i(n=e.data.hook)&&(i(n.create)&&n.create(Aa,e),i(n.insert)&&t.push(e))}function T(e){var t;if(i(t=e.fnScopeId))l.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&l.setStyleScope(e.elm,t),n=n.parent;i(t=St)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&l.setStyleScope(e.elm,t)}function g(e,t,n,a,i,s){for(;a<=i;++a)y(n[a],s,e,t,!1,n,a)}function w(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<p.destroy.length;++t)p.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)w(e.children[n])}function _(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(R(a),w(a)):u(a.elm))}}function R(e,t){if(i(t)||i(e.data)){var n,a=p.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&u(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&R(n,t),n=0;n<p.remove.length;++n)p.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else u(e.elm)}function I(e,t,n,a){for(var s=n;s<a;s++){var r=t[s];if(i(r)&&ka(e,r))return s}}function x(e,t,n,r,o,d){if(e!==t){i(t.elm)&&i(r)&&(t=r[o]=ce(t));var u=t.elm=e.elm;if(s(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?S(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(e.isStatic)&&t.key===e.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=e.componentInstance;else{var c,m=t.data;i(m)&&i(c=m.hook)&&i(c=c.prepatch)&&c(e,t);var f=e.children,h=t.children;if(i(m)&&b(t)){for(c=0;c<p.update.length;++c)p.update[c](e,t);i(c=m.hook)&&i(c=c.update)&&c(e,t)}a(t.text)?i(f)&&i(h)?f!==h&&function(e,t,n,s,r){for(var o,p,d,u=0,c=0,m=t.length-1,f=t[0],h=t[m],b=n.length-1,v=n[0],T=n[b],w=!r;u<=m&&c<=b;)a(f)?f=t[++u]:a(h)?h=t[--m]:ka(f,v)?(x(f,v,s,n,c),f=t[++u],v=n[++c]):ka(h,T)?(x(h,T,s,n,b),h=t[--m],T=n[--b]):ka(f,T)?(x(f,T,s,n,b),w&&l.insertBefore(e,f.elm,l.nextSibling(h.elm)),f=t[++u],T=n[--b]):ka(h,v)?(x(h,v,s,n,c),w&&l.insertBefore(e,h.elm,f.elm),h=t[--m],v=n[++c]):(a(o)&&(o=Pa(t,u,m)),a(p=i(v.key)?o[v.key]:I(v,t,u,m))?y(v,s,e,f.elm,!1,n,c):ka(d=t[p],v)?(x(d,v,s,n,c),t[p]=void 0,w&&l.insertBefore(e,d.elm,f.elm)):y(v,s,e,f.elm,!1,n,c),v=n[++c]);u>m?g(e,a(n[b+1])?null:n[b+1].elm,n,c,b,s):c>b&&_(t,u,m)}(u,f,h,n,d):i(h)?(i(e.text)&&l.setTextContent(u,""),g(u,null,h,0,h.length-1,n)):i(f)?_(f,0,f.length-1):i(e.text)&&l.setTextContent(u,""):e.text!==t.text&&l.setTextContent(u,t.text),i(m)&&i(c=m.hook)&&i(c=c.postpatch)&&c(e,t)}}}function M(e,t,n){if(s(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var A=f("attrs,class,staticClass,staticStyle,key");function S(e,t,n,a){var r,o=t.tag,p=t.data,d=t.children;if(a=a||p&&p.pre,t.elm=e,s(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(p)&&(i(r=p.hook)&&i(r=r.init)&&r(t,!0),i(r=t.componentInstance)))return c(t,n),!0;if(i(o)){if(i(d))if(e.hasChildNodes())if(i(r=p)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var l=!0,u=e.firstChild,y=0;y<d.length;y++){if(!u||!S(u,d[y],n,a)){l=!1;break}u=u.nextSibling}if(!l||u)return!1}else h(t,d,n);if(i(p)){var m=!1;for(var f in p)if(!A(f)){m=!0,v(t,n);break}!m&&p.class&&un(p.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!a(t)){var o,d=!1,u=[];if(a(e))d=!0,y(t,u);else{var c=i(e.nodeType);if(!c&&ka(e,t))x(e,t,u,null,null,r);else{if(c){if(1===e.nodeType&&e.hasAttribute(N)&&(e.removeAttribute(N),n=!0),s(n)&&S(e,t,u))return M(t,u,!0),e;o=e,e=new le(l.tagName(o).toLowerCase(),{},[],void 0,o)}var m=e.elm,f=l.parentNode(m);if(y(t,u,m._leaveCb?null:f,l.nextSibling(m)),i(t.parent))for(var h=t.parent,v=b(t);h;){for(var T=0;T<p.destroy.length;++T)p.destroy[T](h);if(h.elm=t.elm,v){for(var g=0;g<p.create.length;++g)p.create[g](Aa,h);var R=h.data.hook.insert;if(R.merged)for(var I=1;I<R.fns.length;I++)R.fns[I]()}else xa(h);h=h.parent}i(f)?_([e],0,0):i(e.tag)&&w(e)}}return M(t,u,d),t.elm}i(e)&&w(e)}}({nodeOps:Ra,modules:[za,Ka,Ai,Pi,zi,H?{create:cs,activate:cs,remove:function(e,t){!0!==e.data.show?ls(e,t):t()}}:{}].concat(Na)});K&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&_s(e,"input")}));var fs={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?ze(n,"postpatch",(function(){fs.componentUpdated(e,t,n)})):hs(e,t,n.context),e._vOptions=[].map.call(e.options,Ts)):("textarea"===n.tag||wa(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",gs),e.addEventListener("compositionend",ws),e.addEventListener("change",ws),K&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){hs(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,Ts);i.some((function(e,t){return!D(e,a[t])}))&&(e.multiple?t.value.some((function(e){return vs(e,i)})):t.value!==t.oldValue&&vs(t.value,i))&&_s(e,"change")}}};function hs(e,t,n){bs(e,t),(W||J)&&setTimeout((function(){bs(e,t)}),0)}function bs(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,p=e.options.length;o<p;o++)if(r=e.options[o],i)s=$(a,Ts(r))>-1,r.selected!==s&&(r.selected=s);else if(D(Ts(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function vs(e,t){return t.every((function(t){return!D(t,e)}))}function Ts(e){return"_value"in e?e._value:e.value}function gs(e){e.target.composing=!0}function ws(e){e.target.composing&&(e.target.composing=!1,_s(e.target,"input"))}function _s(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Rs(e){return!e.componentInstance||e.data&&e.data.transition?e:Rs(e.componentInstance._vnode)}var Is={model:fs,show:{bind:function(e,t,n){var a=t.value,i=(n=Rs(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,ds(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=Rs(n)).data&&n.data.transition?(n.data.show=!0,a?ds(n,(function(){e.style.display=e.__vOriginalDisplay})):ls(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},xs={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ms(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Ms(Rt(t.children)):e}function As(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[R(a)]=i[a];return t}function Ss(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var ks=function(e){return e.tag||ct(e)},Ps=function(e){return"show"===e.name},Es={name:"transition",props:xs,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(ks)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=Ms(i);if(!s)return i;if(this._leaving)return Ss(e,i);var o="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var p=(s.data||(s.data={})).transition=As(this),d=this._vnode,l=Ms(d);if(s.data.directives&&s.data.directives.some(Ps)&&(s.data.show=!0),l&&l.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,l)&&!ct(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var u=l.data.transition=k({},p);if("out-in"===a)return this._leaving=!0,ze(u,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Ss(e,i);if("in-out"===a){if(ct(s))return d;var y,c=function(){y()};ze(p,"afterEnter",c),ze(p,"enterCancelled",c),ze(u,"delayLeave",(function(e){y=e}))}}return i}}},Cs=k({tag:String,moveClass:String},xs);delete Cs.mode;var Os={props:Cs,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=kt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=As(this),o=0;o<i.length;o++)(l=i[o]).tag&&null!=l.key&&0!==String(l.key).indexOf("__vlist")&&(s.push(l),n[l.key]=l,(l.data||(l.data={})).transition=r);if(a){var p=[],d=[];for(o=0;o<a.length;o++){var l;(l=a[o]).data.transition=r,l.data.pos=l.elm.getBoundingClientRect(),n[l.key]?p.push(l):d.push(l)}this.kept=e(t,null,p),this.removed=d}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Ds),e.forEach($s),e.forEach(js),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;ns(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Zi,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Zi,e),n._moveCb=null,as(n,t))})}})))},methods:{hasMove:function(e,t){if(!Qi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){Li(n,e)})),Bi(n,t),n.style.display="none",this.$el.appendChild(n);var a=rs(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function Ds(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function $s(e){e.data.newPos=e.elm.getBoundingClientRect()}function js(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),s.transitionDuration="0s"}}var Ns={Transition:Es,TransitionGroup:Os};Wn.config.mustUseProp=aa,Wn.config.isReservedTag=va,Wn.config.isReservedAttr=ta,Wn.config.getTagNamespace=Ta,Wn.config.isUnknownElement=function(e){if(!H)return!0;if(va(e))return!1;if(e=e.toLowerCase(),null!=ga[e])return ga[e];var t=document.createElement(e);return e.indexOf("-")>-1?ga[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ga[e]=/HTMLUnknownElement/.test(t.toString())},k(Wn.options.directives,Is),k(Wn.options.components,Ns),Wn.prototype.__patch__=H?ms:E,Wn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=ue),Ot(e,"beforeMount"),a=function(){e._update(e._render(),n)},new mn(e,a,E,{before:function(){e._isMounted&&!e._isDestroyed&&Ot(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var s=0;s<i.length;s++)i[s].run();return null==e.$vnode&&(e._isMounted=!0,Ot(e,"mounted")),e}(this,e=e&&H?_a(e):void 0,t)},H&&setTimeout((function(){q.devtools&&ie&&ie.emit("init",Wn)}),0);var Vs,Fs=/\{\{((?:.|\r?\n)+?)\}\}/g,qs=/[-.*+?^${}()|[\]\/\\]/g,zs=w((function(e){var t=e[0].replace(qs,"\\$&"),n=e[1].replace(qs,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Us={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=pi(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=oi(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},Bs={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=pi(e,"style");n&&(e.staticStyle=JSON.stringify(Ei(n)));var a=oi(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},Ls=f("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Gs=f("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Hs=f("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Qs=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ws=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ks="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(z.source,"]*"),Js="((?:".concat(Ks,"\\:)?").concat(Ks,")"),Zs=new RegExp("^<".concat(Js)),Ys=/^\s*(\/?)>/,Xs=new RegExp("^<\\/".concat(Js,"[^>]*>")),er=/^<!DOCTYPE [^>]+>/i,tr=/^<!\--/,nr=/^<!\[/,ar=f("script,style,textarea",!0),ir={},sr={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},rr=/&(?:lt|gt|quot|amp|#39);/g,or=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,pr=f("pre,textarea",!0),dr=function(e,t){return e&&pr(e)&&"\n"===t[0]};function lr(e,t){var n=t?or:rr;return e.replace(n,(function(e){return sr[e]}))}var ur,yr,cr,mr,fr,hr,br,vr,Tr=/^@|^v-on:/,gr=/^v-|^@|^:|^#/,wr=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,_r=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Rr=/^\(|\)$/g,Ir=/^\[.*\]$/,xr=/:(.*)$/,Mr=/^:|^\.|^v-bind:/,Ar=/\.[^.\]]+(?=[^\]]*$)/g,Sr=/^v-slot(:|$)|^#/,kr=/[\r\n]/,Pr=/[ \f\t\r\n]+/g,Er=w((function(e){return(Vs=Vs||document.createElement("div")).innerHTML=e,Vs.textContent})),Cr="_empty_";function Or(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:qr(t),rawAttrsMap:{},parent:n,children:[]}}function Dr(e,t){ur=t.warn||Xa,hr=t.isPreTag||C,br=t.mustUseProp||C,vr=t.getTagNamespace||C;t.isReservedTag;cr=ei(t.modules,"transformNode"),mr=ei(t.modules,"preTransformNode"),fr=ei(t.modules,"postTransformNode"),yr=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,p=!1;function d(e){if(l(e),o||e.processed||(e=$r(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&Nr(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,d=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),d&&d.if&&Nr(d,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,d;e.children=e.children.filter((function(e){return!e.slotScope})),l(e),e.pre&&(o=!1),hr(e.tag)&&(p=!1);for(var u=0;u<fr.length;u++)fr[u](e,t)}function l(e){if(!p)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||C,o=t.canBeLeftOpenTag||C,p=0,d=function(){if(n=e,a&&ar(a)){var d=0,y=a.toLowerCase(),c=ir[y]||(ir[y]=new RegExp("([\\s\\S]*?)(</"+y+"[^>]*>)","i"));_=e.replace(c,(function(e,n,a){return d=a.length,ar(y)||"noscript"===y||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),dr(y,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),p+=e.length-_.length,e=_,u(y,p-d,p)}else{var m=e.indexOf("<");if(0===m){if(tr.test(e)){var f=e.indexOf("--\x3e");if(f>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,f),p,p+f+3),l(f+3),"continue"}if(nr.test(e)){var h=e.indexOf("]>");if(h>=0)return l(h+2),"continue"}var b=e.match(er);if(b)return l(b[0].length),"continue";var v=e.match(Xs);if(v){var T=p;return l(v[0].length),u(v[1],T,p),"continue"}var g=function(){var t=e.match(Zs);if(t){var n={tagName:t[1],attrs:[],start:p};l(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(Ys))&&(i=e.match(Ws)||e.match(Qs));)i.start=p,l(i[0].length),i.end=p,n.attrs.push(i);if(a)return n.unarySlash=a[1],l(a[0].length),n.end=p,n}}();if(g)return function(e){var n=e.tagName,p=e.unarySlash;s&&("p"===a&&Hs(n)&&u(a),o(n)&&a===n&&u(n));for(var d=r(n)||!!p,l=e.attrs.length,y=new Array(l),c=0;c<l;c++){var m=e.attrs[c],f=m[3]||m[4]||m[5]||"",h="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;y[c]={name:m[1],value:lr(f,h)}}d||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:y,start:e.start,end:e.end}),a=n),t.start&&t.start(n,y,d,e.start,e.end)}(g),dr(g.tagName,e)&&l(1),"continue"}var w=void 0,_=void 0,R=void 0;if(m>=0){for(_=e.slice(m);!(Xs.test(_)||Zs.test(_)||tr.test(_)||nr.test(_)||(R=_.indexOf("<",1))<0);)m+=R,_=e.slice(m);w=e.substring(0,m)}m<0&&(w=e),w&&l(w.length),t.chars&&w&&t.chars(w,p-w.length,p)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==d(););function l(t){p+=t,e=e.substring(t)}function u(e,n,s){var r,o;if(null==n&&(n=p),null==s&&(s=p),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var d=i.length-1;d>=r;d--)t.end&&t.end(i[d].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}u()}(e,{warn:ur,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,l,u){var y=a&&a.ns||vr(e);W&&"svg"===y&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];zr.test(a.name)||(a.name=a.name.replace(Ur,""),t.push(a))}return t}(s));var c,m=Or(e,s,a);y&&(m.ns=y),"style"!==(c=m).tag&&("script"!==c.tag||c.attrsMap.type&&"text/javascript"!==c.attrsMap.type)||ae()||(m.forbidden=!0);for(var f=0;f<mr.length;f++)m=mr[f](m,t)||m;o||(function(e){null!=pi(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),hr(m.tag)&&(p=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(jr(m),function(e){var t=pi(e,"v-if");if(t)e.if=t,Nr(e,{exp:t,block:e});else{null!=pi(e,"v-else")&&(e.else=!0);var n=pi(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=pi(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),r?d(m):(a=m,i.push(m))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],d(s)},chars:function(e,t,n){if(a&&(!W||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,d=a.children;if(e=p||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:Er(e):d.length?r?"condense"===r&&kr.test(e)?"":" ":s?" ":"":""){p||"condense"!==r||(e=e.replace(Pr," "));var l=void 0,u=void 0;!o&&" "!==e&&(l=function(e,t){var n=t?zs(t):Fs;if(n.test(e)){for(var a,i,s,r=[],o=[],p=n.lastIndex=0;a=n.exec(e);){(i=a.index)>p&&(o.push(s=e.slice(p,i)),r.push(JSON.stringify(s)));var d=Za(a[1].trim());r.push("_s(".concat(d,")")),o.push({"@binding":d}),p=i+a[0].length}return p<e.length&&(o.push(s=e.slice(p)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,yr))?u={type:2,expression:l.expression,tokens:l.tokens,text:e}:" "===e&&d.length&&" "===d[d.length-1].text||(u={type:3,text:e}),u&&d.push(u)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function $r(e,t){var n;!function(e){var t=oi(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=oi(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=pi(e,"scope"),e.slotScope=t||pi(e,"slot-scope")):(t=pi(e,"slot-scope"))&&(e.slotScope=t);var n,a=oi(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||ni(e,"slot",a,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot"))),"template"===e.tag){if(n=di(e,Sr)){var i=Vr(n),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=n.value||Cr}}else if(n=di(e,Sr)){var o=e.scopedSlots||(e.scopedSlots={}),p=Vr(n),d=p.name,l=(r=p.dynamic,o[d]=Or("template",[],e));l.slotTarget=d,l.slotTargetDynamic=r,l.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=l,!0})),l.slotScope=n.value||Cr,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=oi(n,"name")),function(e){var t;(t=oi(e,"is"))&&(e.component=t),null!=pi(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<cr.length;a++)e=cr[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,p,d=e.attrsList;for(t=0,n=d.length;t<n;t++)if(a=i=d[t].name,s=d[t].value,gr.test(a))if(e.hasBindings=!0,(r=Fr(a.replace(gr,"")))&&(a=a.replace(Ar,"")),Mr.test(a))a=a.replace(Mr,""),s=Za(s),(p=Ir.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!p&&"innerHtml"===(a=R(a))&&(a="innerHTML"),r.camel&&!p&&(a=R(a)),r.sync&&(o=yi(s,"$event"),p?ri(e,'"update:"+('.concat(a,")"),o,null,!1,0,d[t],!0):(ri(e,"update:".concat(R(a)),o,null,!1,0,d[t]),M(a)!==R(a)&&ri(e,"update:".concat(M(a)),o,null,!1,0,d[t])))),r&&r.prop||!e.component&&br(e.tag,e.attrsMap.type,a)?ti(e,a,s,d[t],p):ni(e,a,s,d[t],p);else if(Tr.test(a))a=a.replace(Tr,""),(p=Ir.test(a))&&(a=a.slice(1,-1)),ri(e,a,s,r,!1,0,d[t],p);else{var l=(a=a.replace(gr,"")).match(xr),u=l&&l[1];p=!1,u&&(a=a.slice(0,-(u.length+1)),Ir.test(u)&&(u=u.slice(1,-1),p=!0)),ii(e,a,i,s,u,p,r,d[t])}else ni(e,a,JSON.stringify(s),d[t]),!e.component&&"muted"===a&&br(e.tag,e.attrsMap.type,a)&&ti(e,a,"true",d[t])}(e),e}function jr(e){var t;if(t=pi(e,"v-for")){var n=function(e){var t=e.match(wr);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(Rr,""),i=a.match(_r);return i?(n.alias=a.replace(_r,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&k(e,n)}}function Nr(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Vr(e){var t=e.name.replace(Sr,"");return t||"#"!==e.name[0]&&(t="default"),Ir.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function Fr(e){var t=e.match(Ar);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function qr(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var zr=/^xmlns:NS\d+/,Ur=/^NS\d+:/;function Br(e){return Or(e.tag,e.attrsList.slice(),e.parent)}var Lr,Gr,Hr=[Us,Bs,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=oi(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=pi(e,"v-if",!0),s=i?"&&(".concat(i,")"):"",r=null!=pi(e,"v-else",!0),o=pi(e,"v-else-if",!0),p=Br(e);jr(p),ai(p,"type","checkbox"),$r(p,t),p.processed=!0,p.if="(".concat(a,")==='checkbox'")+s,Nr(p,{exp:p.if,block:p});var d=Br(e);pi(d,"v-for",!0),ai(d,"type","radio"),$r(d,t),Nr(p,{exp:"(".concat(a,")==='radio'")+s,block:d});var l=Br(e);return pi(l,"v-for",!0),ai(l,":type",a),$r(l,t),Nr(p,{exp:i,block:l}),r?p.else=!0:o&&(p.elseif=o),p}}}}],Qr={expectHTML:!0,modules:Hr,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return ui(e,a,i),!1;if("select"===s)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),s="var $$selectedVal = ".concat(i,";");ri(e,"change",s="".concat(s," ").concat(yi(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=oi(e,"value")||"null",s=oi(e,"true-value")||"true",r=oi(e,"false-value")||"false";ti(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===s?":(".concat(t,")"):":_q(".concat(t,",").concat(s,")"))),ri(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(s,"):(").concat(r,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(yi(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(yi(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(yi(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=oi(e,"value")||"null";i=a?"_n(".concat(i,")"):i,ti(e,"checked","_q(".concat(t,",").concat(i,")")),ri(e,"change",yi(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,p=!s&&"range"!==a,d=s?"change":"range"===a?Ti:"input",l="$event.target.value";o&&(l="$event.target.value.trim()"),r&&(l="_n(".concat(l,")"));var u=yi(t,l);p&&(u="if($event.target.composing)return;".concat(u)),ti(e,"value","(".concat(t,")")),ri(e,d,u,null,!0),(o||r)&&ri(e,"blur","$forceUpdate()")}(e,a,i);else if(!q.isReservedTag(s))return ui(e,a,i),!1;return!0},text:function(e,t){t.value&&ti(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&ti(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:Ls,mustUseProp:aa,canBeLeftOpenTag:Gs,isReservedTag:va,getTagNamespace:Ta,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(Hr)},Wr=w((function(e){return f("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Kr(e,t){e&&(Lr=Wr(t.staticKeys||""),Gr=t.isReservedTag||C,Jr(e),Zr(e,!1))}function Jr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||h(e.tag)||!Gr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(Lr))))}(e),1===e.type){if(!Gr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Jr(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;Jr(i),i.static||(e.static=!1)}}}function Zr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Zr(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)Zr(e.ifConditions[n].block,t)}}var Yr=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Xr=/\([^)]*?\);*$/,eo=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,to={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},no={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},ao=function(e){return"if(".concat(e,")return null;")},io={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:ao("$event.target !== $event.currentTarget"),ctrl:ao("!$event.ctrlKey"),shift:ao("!$event.shiftKey"),alt:ao("!$event.altKey"),meta:ao("!$event.metaKey"),left:ao("'button' in $event && $event.button !== 0"),middle:ao("'button' in $event && $event.button !== 1"),right:ao("'button' in $event && $event.button !== 2")};function so(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=ro(e[s]);e[s]&&e[s].dynamic?i+="".concat(s,",").concat(r,","):a+='"'.concat(s,'":').concat(r,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function ro(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return ro(e)})).join(","),"]");var t=eo.test(e.value),n=Yr.test(e.value),a=eo.test(e.value.replace(Xr,""));if(e.modifiers){var i="",s="",r=[],o=function(t){if(io[t])s+=io[t],to[t]&&r.push(t);else if("exact"===t){var n=e.modifiers;s+=ao(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else r.push(t)};for(var p in e.modifiers)o(p);r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(oo).join("&&"),")return null;")}(r)),s&&(i+=s);var d=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(d,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function oo(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=to[e],a=no[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var po={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:E},lo=function(e){this.options=e,this.warn=e.warn||Xa,this.transforms=ei(e.modules,"transformCode"),this.dataGenFns=ei(e.modules,"genData"),this.directives=k(k({},po),e.directives);var t=e.isReservedTag||C;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function uo(e,t){var n=new lo(t),a=e?"script"===e.tag?"null":yo(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function yo(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return co(e,t);if(e.once&&!e.onceProcessed)return mo(e,t);if(e.for&&!e.forProcessed)return bo(e,t);if(e.if&&!e.ifProcessed)return fo(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=wo(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),s=e.attrs||e.dynamicAttrs?Io((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:R(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=",".concat(s)),r&&(i+="".concat(s?"":",null",",").concat(r)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:wo(t,n,!0);return"_c(".concat(e,",").concat(vo(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=vo(e,t));var s=void 0,r=t.options.bindings;i&&r&&!1!==r.__isScriptSetup&&(s=function(e,t){var n=R(t),a=I(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},s=i("setup-const")||i("setup-reactive-const");if(s)return s;var r=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return r||void 0}(r,e.tag)),s||(s="'".concat(e.tag,"'"));var o=e.inlineTemplate?null:wo(e,t,!0);n="_c(".concat(s).concat(a?",".concat(a):"").concat(o?",".concat(o):"",")")}for(var p=0;p<t.transforms.length;p++)n=t.transforms[p](e,n);return n}return wo(e,t)||"void 0"}function co(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(yo(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function mo(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return fo(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(yo(e,t),",").concat(t.onceId++,",").concat(n,")"):yo(e,t)}return co(e,t)}function fo(e,t,n,a){return e.ifProcessed=!0,ho(e.ifConditions.slice(),t,n,a)}function ho(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(s(i.block),":").concat(ho(e,t,n,a)):"".concat(s(i.block));function s(e){return n?n(e,t):e.once?mo(e,t):yo(e,t)}}function bo(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?",".concat(e.iterator1):"",o=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(s).concat(r).concat(o,"){")+"return ".concat((n||yo)(e,t))+"})"}function vo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",p=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var d=t.directives[s.name];d&&(r=!!d(e,s,t.warn)),r&&(p=!0,o+='{name:"'.concat(s.name,'",rawName:"').concat(s.rawName,'"').concat(s.value?",value:(".concat(s.value,"),expression:").concat(JSON.stringify(s.value)):"").concat(s.arg?",arg:".concat(s.isDynamicArg?s.arg:'"'.concat(s.arg,'"')):"").concat(s.modifiers?",modifiers:".concat(JSON.stringify(s.modifiers)):"","},"))}return p?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(Io(e.attrs),",")),e.props&&(n+="domProps:".concat(Io(e.props),",")),e.events&&(n+="".concat(so(e.events,!1),",")),e.nativeEvents&&(n+="".concat(so(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||To(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==Cr||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return go(t[e],n)})).join(",");return"scopedSlots:_u([".concat(r,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=uo(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);s&&(n+="".concat(s,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(Io(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function To(e){return 1===e.type&&("slot"===e.tag||e.children.some(To))}function go(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return fo(e,t,go,"null");if(e.for&&!e.forProcessed)return bo(e,t,go);var a=e.slotScope===Cr?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(wo(e,t)||"undefined",":undefined"):wo(e,t)||"undefined":yo(e,t),"}"),s=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(s,"}")}function wo(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return"".concat((a||yo)(r,t)).concat(o)}var p=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(_o(i)||i.ifConditions&&i.ifConditions.some((function(e){return _o(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,d=i||Ro;return"[".concat(s.map((function(e){return d(e,t)})).join(","),"]").concat(p?",".concat(p):"")}}function _o(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function Ro(e,t){return 1===e.type?yo(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:xo(JSON.stringify(n.text)),")");var n}function Io(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=xo(i.value);i.dynamic?n+="".concat(i.name,",").concat(s,","):t+='"'.concat(i.name,'":').concat(s,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function xo(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function Mo(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),E}}function Ao(e){var t=Object.create(null);return function(n,a,i){(a=k({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},p=[];return o.render=Mo(r.render,p),o.staticRenderFns=r.staticRenderFns.map((function(e){return Mo(e,p)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var So,ko,Po=(So=function(e,t){var n=Dr(e.trim(),t);!1!==t.optimize&&Kr(n,t);var a=uo(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=k(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=So(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:Ao(t)}}),Eo=Po(Qr).compileToFunctions;function Co(e){return(ko=ko||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',ko.innerHTML.indexOf("&#10;")>0}var Oo=!!H&&Co(!1),Do=!!H&&Co(!0),$o=w((function(e){var t=_a(e);return t&&t.innerHTML})),jo=Wn.prototype.$mount;function No(e,t){for(var n in t)e[n]=t[n];return e}Wn.prototype.$mount=function(e,t){if((e=e&&_a(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=$o(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=Eo(a,{outputSourceRange:!1,shouldDecodeNewlines:Oo,shouldDecodeNewlinesForHref:Do,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return jo.call(this,e,t)},Wn.compile=Eo;var Vo=/[!'()*]/g,Fo=function(e){return"%"+e.charCodeAt(0).toString(16)},qo=/%2C/g,zo=function(e){return encodeURIComponent(e).replace(Vo,Fo).replace(qo,",")};function Uo(e){try{return decodeURIComponent(e)}catch(e){}return e}var Bo=function(e){return null==e||"object"==typeof e?e:String(e)};function Lo(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=Uo(n.shift()),i=n.length>0?Uo(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Go(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return zo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(zo(t)):a.push(zo(t)+"="+zo(e)))})),a.join("&")}return zo(t)+"="+zo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Ho=/\/?$/;function Qo(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=Wo(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Zo(t,i),matched:e?Jo(e):[]};return n&&(r.redirectedFrom=Zo(n,i)),Object.freeze(r)}function Wo(e){if(Array.isArray(e))return e.map(Wo);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Wo(e[n]);return t}return e}var Ko=Qo(null,{path:"/"});function Jo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Zo(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Go)(a)+i}function Yo(e,t,n){return t===Ko?e===t:!!t&&(e.path&&t.path?e.path.replace(Ho,"")===t.path.replace(Ho,"")&&(n||e.hash===t.hash&&Xo(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Xo(e.query,t.query)&&Xo(e.params,t.params)))}function Xo(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?Xo(s,r):String(s)===String(r)}))}function ep(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var tp={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,p=i.$route,d=i._routerViewCache||(i._routerViewCache={}),l=0,u=!1;i&&i._routerRoot!==i;){var y=i.$vnode?i.$vnode.data:{};y.routerView&&l++,y.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(s.routerViewDepth=l,u){var c=d[o],m=c&&c.component;return m?(c.configProps&&np(m,s,c.route,c.configProps),r(m,s,a)):r()}var f=p.matched[l],h=f&&f.components[o];if(!f||!h)return d[o]=null,r();d[o]={component:h},s.registerRouteInstance=function(e,t){var n=f.instances[o];(t&&n!==e||!t&&n===e)&&(f.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){f.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[o]&&(f.instances[o]=e.componentInstance),ep(p)};var b=f.props&&f.props[o];return b&&(No(d[o],{route:p,configProps:b}),np(h,s,p,b)),r(h,s,a)}};function np(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=No({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function ap(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function ip(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var sp=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},rp=function e(t,n,a){return sp(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return bp(e,t)}(t,n):sp(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return bp(new RegExp("(?:"+i.join("|")+")",vp(a)),n)}(t,n,a):function(e,t,n){return Tp(up(e,n),t,n)}(t,n,a)},op=up,pp=mp,dp=Tp,lp=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function up(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=lp.exec(e));){var p=n[0],d=n[1],l=n.index;if(r+=e.slice(s,l),s=l+p.length,d)r+=d[1];else{var u=e[s],y=n[2],c=n[3],m=n[4],f=n[5],h=n[6],b=n[7];r&&(a.push(r),r="");var v=null!=y&&null!=u&&u!==y,T="+"===h||"*"===h,g="?"===h||"*"===h,w=n[2]||o,_=m||f;a.push({name:c||i++,prefix:y||"",delimiter:w,optional:g,repeat:T,partial:v,asterisk:!!b,pattern:_?hp(_):b?".*":"[^"+fp(w)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function yp(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function cp(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function mp(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",vp(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?yp:encodeURIComponent,o=0;o<e.length;o++){var p=e[o];if("string"!=typeof p){var d,l=s[p.name];if(null==l){if(p.optional){p.partial&&(i+=p.prefix);continue}throw new TypeError('Expected "'+p.name+'" to be defined')}if(sp(l)){if(!p.repeat)throw new TypeError('Expected "'+p.name+'" to not repeat, but received `'+JSON.stringify(l)+"`");if(0===l.length){if(p.optional)continue;throw new TypeError('Expected "'+p.name+'" to not be empty')}for(var u=0;u<l.length;u++){if(d=r(l[u]),!n[o].test(d))throw new TypeError('Expected all "'+p.name+'" to match "'+p.pattern+'", but received `'+JSON.stringify(d)+"`");i+=(0===u?p.prefix:p.delimiter)+d}}else{if(d=p.asterisk?cp(l):r(l),!n[o].test(d))throw new TypeError('Expected "'+p.name+'" to match "'+p.pattern+'", but received "'+d+'"');i+=p.prefix+d}}else i+=p}return i}}function fp(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function hp(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function bp(e,t){return e.keys=t,e}function vp(e){return e&&e.sensitive?"":"i"}function Tp(e,t,n){sp(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=fp(o);else{var p=fp(o.prefix),d="(?:"+o.pattern+")";t.push(o),o.repeat&&(d+="(?:"+p+d+")*"),s+=d=o.optional?o.partial?p+"("+d+")?":"(?:"+p+"("+d+"))?":p+"("+d+")"}}var l=fp(n.delimiter||"/"),u=s.slice(-l.length)===l;return a||(s=(u?s.slice(0,-l.length):s)+"(?:"+l+"(?=$))?"),s+=i?"$":a&&u?"":"(?="+l+"|$)",bp(new RegExp("^"+s,vp(n)),t)}rp.parse=op,rp.compile=function(e,t){return mp(up(e,t),t)},rp.tokensToFunction=pp,rp.tokensToRegExp=dp;var gp=Object.create(null);function wp(e,t,n){t=t||{};try{var a=gp[e]||(gp[e]=rp.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function _p(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=No({},e)).params;return s&&"object"==typeof s&&(i.params=No({},s)),i}if(!i.path&&i.params&&t){(i=No({},i))._normalized=!0;var r=No(No({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=wp(o,r,t.path)}return i}var p=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),d=t&&t.path||"/",l=p.path?ap(p.path,d,n||i.append):d,u=function(e,t,n){void 0===t&&(t={});var a,i=n||Lo;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(Bo):Bo(r)}return a}(p.query,i.query,a&&a.options.parseQuery),y=i.hash||p.hash;return y&&"#"!==y.charAt(0)&&(y="#"+y),{_normalized:!0,path:l,query:u,hash:y}}var Rp,Ip=function(){},xp={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,p={},d=n.options.linkActiveClass,l=n.options.linkExactActiveClass,u=null==d?"router-link-active":d,y=null==l?"router-link-exact-active":l,c=null==this.activeClass?u:this.activeClass,m=null==this.exactActiveClass?y:this.exactActiveClass,f=r.redirectedFrom?Qo(null,_p(r.redirectedFrom),null,n):r;p[m]=Yo(a,f,this.exactPath),p[c]=this.exact||this.exactPath?p[m]:function(e,t){return 0===e.path.replace(Ho,"/").indexOf(t.path.replace(Ho,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var h=p[m]?this.ariaCurrentValue:null,b=function(e){Mp(e)&&(t.replace?n.replace(s,Ip):n.push(s,Ip))},v={click:Mp};Array.isArray(this.event)?this.event.forEach((function(e){v[e]=b})):v[this.event]=b;var T={class:p},g=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:b,isActive:p[c],isExactActive:p[m]});if(g){if(1===g.length)return g[0];if(g.length>1||!g.length)return 0===g.length?e():e("span",{},g)}if("a"===this.tag)T.on=v,T.attrs={href:o,"aria-current":h};else{var w=Ap(this.$slots.default);if(w){w.isStatic=!1;var _=w.data=No({},w.data);for(var R in _.on=_.on||{},_.on){var I=_.on[R];R in v&&(_.on[R]=Array.isArray(I)?I:[I])}for(var x in v)x in _.on?_.on[x].push(v[x]):_.on[x]=b;var M=w.data.attrs=No({},w.data.attrs);M.href=o,M["aria-current"]=h}else T.on=v}return e(this.tag,T,this.$slots.default)}};function Mp(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function Ap(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=Ap(t.children)))return t}}var Sp="undefined"!=typeof window;function kp(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){Pp(s,r,o,e,i)}));for(var p=0,d=s.length;p<d;p++)"*"===s[p]&&(s.push(s.splice(p,1)[0]),d--,p--);return{pathList:s,pathMap:r,nameMap:o}}function Pp(e,t,n,a,i,s){var r=a.path,o=a.name,p=a.pathToRegexpOptions||{},d=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:ip(t.path+"/"+e)}(r,i,p.strict);"boolean"==typeof a.caseSensitive&&(p.sensitive=a.caseSensitive);var l={path:d,regex:Ep(d,p),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?ip(s+"/"+a.path):void 0;Pp(e,t,n,a,l,i)})),t[l.path]||(e.push(l.path),t[l.path]=l),void 0!==a.alias)for(var u=Array.isArray(a.alias)?a.alias:[a.alias],y=0;y<u.length;++y){var c={path:u[y],children:a.children};Pp(e,t,n,c,i,l.path||"/")}o&&(n[o]||(n[o]=l))}function Ep(e,t){return rp(e,[],t)}function Cp(e,t){var n=kp(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var p=_p(e,n,!1,t),d=p.name;if(d){var l=s[d];if(!l)return o(null,p);var u=l.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof p.params&&(p.params={}),n&&"object"==typeof n.params)for(var y in n.params)!(y in p.params)&&u.indexOf(y)>-1&&(p.params[y]=n.params[y]);return p.path=wp(l.path,p.params),o(l,p,r)}if(p.path){p.params={};for(var c=0;c<a.length;c++){var m=a[c],f=i[m];if(Op(f.regex,p.path,p.params))return o(f,p,r)}}return o(null,p)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(Qo(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var p=i,d=p.name,l=p.path,u=n.query,y=n.hash,c=n.params;if(u=p.hasOwnProperty("query")?p.query:u,y=p.hasOwnProperty("hash")?p.hash:y,c=p.hasOwnProperty("params")?p.params:c,d)return s[d],r({_normalized:!0,name:d,query:u,hash:y,params:c},void 0,n);if(l){var m=function(e,t){return ap(e,t.parent?t.parent.path:"/",!0)}(l,e);return r({_normalized:!0,path:wp(m,c),query:u,hash:y},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:wp(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):Qo(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;kp([t||e],a,i,s,n),n&&n.alias.length&&kp(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){kp(e,a,i,s)}}}function Op(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?Uo(a[i]):a[i])}return!0}var Dp=Sp&&window.performance&&window.performance.now?window.performance:Date;function $p(){return Dp.now().toFixed(3)}var jp=$p();function Np(){return jp}function Vp(e){return jp=e}var Fp=Object.create(null);function qp(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=No({},window.history.state);return n.key=Np(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Bp),function(){window.removeEventListener("popstate",Bp)}}function zp(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=Np();if(e)return Fp[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){Wp(e,s)})).catch((function(e){})):Wp(r,s))}))}}function Up(){var e=Np();e&&(Fp[e]={x:window.pageXOffset,y:window.pageYOffset})}function Bp(e){Up(),e.state&&e.state.key&&Vp(e.state.key)}function Lp(e){return Hp(e.x)||Hp(e.y)}function Gp(e){return{x:Hp(e.x)?e.x:window.pageXOffset,y:Hp(e.y)?e.y:window.pageYOffset}}function Hp(e){return"number"==typeof e}var Qp=/^#\d/;function Wp(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Qp.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Hp((n=s).x)?n.x:0,y:Hp(n.y)?n.y:0})}else Lp(e)&&(t=Gp(e))}else a&&Lp(e)&&(t=Gp(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Kp,Jp=Sp&&(-1===(Kp=window.navigator.userAgent).indexOf("Android 2.")&&-1===Kp.indexOf("Android 4.0")||-1===Kp.indexOf("Mobile Safari")||-1!==Kp.indexOf("Chrome")||-1!==Kp.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Zp(e,t){Up();var n=window.history;try{if(t){var a=No({},n.state);a.key=Np(),n.replaceState(a,"",e)}else n.pushState({key:Vp($p())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Yp(e){Zp(e,!0)}var Xp={redirected:2,aborted:4,cancelled:8,duplicated:16};function ed(e,t){return td(e,t,Xp.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function td(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var nd=["params","query","hash"];function ad(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function id(e,t){return ad(e)&&e._isRouter&&(null==t||e.type===t)}function sd(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}function rd(e,t){return od(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function od(e){return Array.prototype.concat.apply([],e)}var pd="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function dd(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var ld=function(e,t){this.router=e,this.base=function(e){if(!e)if(Sp){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Ko,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ud(e,t,n,a){var i=rd(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=Rp.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return od(a?i.reverse():i)}function yd(e,t){if(t)return function(){return e.apply(t,arguments)}}ld.prototype.listen=function(e){this.cb=e},ld.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},ld.prototype.onError=function(e){this.errorCbs.push(e)},ld.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(id(e,Xp.redirected)&&s===Ko||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},ld.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!id(e)&&ad(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},p=e.matched.length-1,d=i.matched.length-1;if(Yo(e,i)&&p===d&&e.matched[p]===i.matched[d])return this.ensureURL(),e.hash&&zp(this.router,i,e,!1),o(((r=td(s=i,e,Xp.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var l,u=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),y=u.updated,c=u.deactivated,m=u.activated,f=[].concat(function(e){return ud(e,"beforeRouteLeave",yd,!0)}(c),this.router.beforeHooks,function(e){return ud(e,"beforeRouteUpdate",yd)}(y),m.map((function(e){return e.beforeEnter})),(l=m,function(e,t,n){var a=!1,i=0,s=null;rd(l,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var p,d=dd((function(t){var a;((a=t).__esModule||pd&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:Rp.extend(t),r.components[o]=t,--i<=0&&n()})),l=dd((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=ad(e)?e:new Error(t),n(s))}));try{p=e(d,l)}catch(e){l(e)}if(p)if("function"==typeof p.then)p.then(d,l);else{var u=p.component;u&&"function"==typeof u.then&&u.then(d,l)}}})),a||n()})),h=function(t,n){if(a.pending!==e)return o(ed(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return td(e,t,Xp.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):ad(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return td(e,t,Xp.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return nd.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};sd(f,h,(function(){var n=function(e){return ud(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(m);sd(n.concat(a.router.resolveHooks),h,(function(){if(a.pending!==e)return o(ed(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){ep(e)}))}))}))},ld.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},ld.prototype.setupListeners=function(){},ld.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Ko,this.pending=null};var cd=function(e){function t(t,n){e.call(this,t,n),this._startLocation=md(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Jp&&n;a&&this.listeners.push(qp());var i=function(){var n=e.current,i=md(e.base);e.current===Ko&&i===e._startLocation||e.transitionTo(i,(function(e){a&&zp(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Zp(ip(a.base+e.fullPath)),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Yp(ip(a.base+e.fullPath)),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(md(this.base)!==this.current.fullPath){var t=ip(this.base+this.current.fullPath);e?Zp(t):Yp(t)}},t.prototype.getCurrentLocation=function(){return md(this.base)},t}(ld);function md(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(ip(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var fd=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=md(e);if(!/^\/#/.test(t))return window.location.replace(ip(e+"/#"+t)),!0}(this.base)||hd()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Jp&&t;n&&this.listeners.push(qp());var a=function(){var t=e.current;hd()&&e.transitionTo(bd(),(function(a){n&&zp(e.router,a,t,!0),Jp||gd(a.fullPath)}))},i=Jp?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Td(e.fullPath),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){gd(e.fullPath),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;bd()!==t&&(e?Td(t):gd(t))},t.prototype.getCurrentLocation=function(){return bd()},t}(ld);function hd(){var e=bd();return"/"===e.charAt(0)||(gd("/"+e),!1)}function bd(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function vd(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function Td(e){Jp?Zp(vd(e)):window.location.hash=e}function gd(e){Jp?Yp(vd(e)):window.location.replace(vd(e))}var wd=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){id(e,Xp.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(ld),_d=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Cp(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Jp&&!1!==e.fallback,this.fallback&&(t="hash"),Sp||(t="abstract"),this.mode=t,t){case"history":this.history=new cd(this,e.base);break;case"hash":this.history=new fd(this,e.base,this.fallback);break;case"abstract":this.history=new wd(this,e.base)}},Rd={currentRoute:{configurable:!0}};_d.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},Rd.currentRoute.get=function(){return this.history&&this.history.current},_d.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof cd||n instanceof fd){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Jp&&i&&"fullPath"in e&&zp(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},_d.prototype.beforeEach=function(e){return xd(this.beforeHooks,e)},_d.prototype.beforeResolve=function(e){return xd(this.resolveHooks,e)},_d.prototype.afterEach=function(e){return xd(this.afterHooks,e)},_d.prototype.onReady=function(e,t){this.history.onReady(e,t)},_d.prototype.onError=function(e){this.history.onError(e)},_d.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},_d.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},_d.prototype.go=function(e){this.history.go(e)},_d.prototype.back=function(){this.go(-1)},_d.prototype.forward=function(){this.go(1)},_d.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},_d.prototype.resolve=function(e,t,n){var a=_p(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?ip(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},_d.prototype.getRoutes=function(){return this.matcher.getRoutes()},_d.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Ko&&this.history.transitionTo(this.history.getCurrentLocation())},_d.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Ko&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(_d.prototype,Rd);var Id=_d;function xd(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}_d.install=function e(t){if(!e.installed||Rp!==t){e.installed=!0,Rp=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",tp),t.component("RouterLink",xp);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},_d.version="3.6.5",_d.isNavigationFailure=id,_d.NavigationFailureType=Xp,_d.START_LOCATION=Ko,Sp&&window.Vue&&window.Vue.use(_d);var Md=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function Ad(e,t,n,a,i,s,r,o){var p,d="function"==typeof e?e.options:e;if(t&&(d.render=t,d.staticRenderFns=n,d._compiled=!0),a&&(d.functional=!0),s&&(d._scopeId="data-v-"+s),r?(p=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},d._ssrRegister=p):i&&(p=o?function(){i.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:i),p)if(d.functional){d._injectStyles=p;var l=d.render;d.render=function(e,t){return p.call(t),l(e,t)}}else{var u=d.beforeCreate;d.beforeCreate=u?[].concat(u,p):[p]}return{exports:e,options:d}}Md._withStripped=!0,n(838);const Sd=Ad({},Md,[],!1,null,null,null).exports;var kd=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};kd._withStripped=!0;var Pd=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Pd._withStripped=!0;const Ed=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}'),Cd=Ad({data:function(){return{repository:Ed.cj,name:Ed.u2}},methods:{openLink(e){window.open(e,"_blank")}}},Pd,[],!1,null,null,null).exports;var Od=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};Od._withStripped=!0;const Dd=Ad({},Od,[],!1,null,null,null).exports;var $d=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};$d._withStripped=!0;var jd=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};jd._withStripped=!0;const Nd={components:{MemberSection:Ad({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},jd,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},Vd=Ad(Nd,$d,[],!1,null,null,null).exports;var Fd=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};Fd._withStripped=!0;var qd=Ad({components:{Member:Vd},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Fd,[],!1,null,null,null);const zd=Ad({components:{Member:Vd,MemberSet:qd.exports,HeaderBar:Dd,FooterBar:Cd},props:{json:{type:Object,default:()=>new Object}}},kd,[],!1,null,null,null).exports;var Ud=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};Ud._withStripped=!0;var Bd=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};Bd._withStripped=!0;var Ld=Ad({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Bd,[],!1,null,null,null);const Gd=Ad({components:{Branch:Ld.exports,FooterBar:Cd},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Ud,[],!1,null,null,null).exports;Wn.use(Id);const Hd={"@ethereum-attestation-service/eas-contracts/contracts/IEAS.sol:IEAS":{source:"@ethereum-attestation-service/eas-contracts/contracts/IEAS.sol",name:"IEAS",title:"EAS - Ethereum Attestation Service interface.",events:{"Attested(address,address,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"address",name:"attester",type:"address"},{indexed:!1,internalType:"bytes32",name:"uid",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"schema",type:"bytes32"}],name:"Attested",type:"event",details:"Emitted when an attestation has been made.",params:{attester:"The attesting account.",recipient:"The recipient of the attestation.",schema:"The UID of the schema.",uid:"The UID the revoked attestation."}},"Revoked(address,address,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"address",name:"attester",type:"address"},{indexed:!1,internalType:"bytes32",name:"uid",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"schema",type:"bytes32"}],name:"Revoked",type:"event",details:"Emitted when an attestation has been revoked.",params:{attester:"The attesting account.",recipient:"The recipient of the attestation.",schema:"The UID of the schema.",uid:"The UID the revoked attestation."}},"RevokedOffchain(address,bytes32,uint64)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"revoker",type:"address"},{indexed:!0,internalType:"bytes32",name:"data",type:"bytes32"},{indexed:!0,internalType:"uint64",name:"timestamp",type:"uint64"}],name:"RevokedOffchain",type:"event",details:"Emitted when a data has been revoked.",params:{data:"The data.",revoker:"The address of the revoker.",timestamp:"The timestamp."}},"Timestamped(bytes32,uint64)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"data",type:"bytes32"},{indexed:!0,internalType:"uint64",name:"timestamp",type:"uint64"}],name:"Timestamped",type:"event",details:"Emitted when a data has been timestamped.",params:{data:"The data.",timestamp:"The timestamp."}}},methods:{"attest((bytes32,(address,uint64,bool,bytes32,bytes,uint256)))":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct AttestationRequestData",name:"data",type:"tuple"}],internalType:"struct AttestationRequest",name:"request",type:"tuple"}],name:"attest",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"payable",type:"function",details:"Attests to a specific schema.",params:{request:'The arguments of the attestation request. Example: attest({     schema: "0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0",     data: {         recipient: "0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf",         expirationTime: 0,         revocable: true,         refUID: "0x0000000000000000000000000000000000000000000000000000000000000000",         data: "0xF00D",         value: 0     } })'},returns:{_0:"The UID of the new attestation."}},"attestByDelegation((bytes32,(address,uint64,bool,bytes32,bytes,uint256),(uint8,bytes32,bytes32),address))":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct AttestationRequestData",name:"data",type:"tuple"},{components:[{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct EIP712Signature",name:"signature",type:"tuple"},{internalType:"address",name:"attester",type:"address"}],internalType:"struct DelegatedAttestationRequest",name:"delegatedRequest",type:"tuple"}],name:"attestByDelegation",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"payable",type:"function",details:"Attests to a specific schema via the provided EIP712 signature.",params:{delegatedRequest:"The arguments of the delegated attestation request. Example: attestByDelegation({     schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',     data: {         recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',         expirationTime: 1673891048,         revocable: true,         refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',         data: '0x1234',         value: 0     },     signature: {         v: 28,         r: '0x148c...b25b',         s: '0x5a72...be22'     },     attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e' })"},returns:{_0:"The UID of the new attestation."}},"getAttestation(bytes32)":{inputs:[{internalType:"bytes32",name:"uid",type:"bytes32"}],name:"getAttestation",outputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns an existing attestation by UID.",params:{uid:"The UID of the attestation to retrieve."},returns:{_0:"The attestation data members."}},"getRevokeOffchain(address,bytes32)":{inputs:[{internalType:"address",name:"revoker",type:"address"},{internalType:"bytes32",name:"data",type:"bytes32"}],name:"getRevokeOffchain",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function",details:"Returns the timestamp that the specified data was timestamped with.",params:{data:"The data to query."},returns:{_0:"The timestamp the data was timestamped with."}},"getSchemaRegistry()":{inputs:[],name:"getSchemaRegistry",outputs:[{internalType:"contract ISchemaRegistry",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the global schema registry.",returns:{_0:"The address of the global schema registry."}},"getTimestamp(bytes32)":{inputs:[{internalType:"bytes32",name:"data",type:"bytes32"}],name:"getTimestamp",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function",details:"Returns the timestamp that the specified data was timestamped with.",params:{data:"The data to query."},returns:{_0:"The timestamp the data was timestamped with."}},"isAttestationValid(bytes32)":{inputs:[{internalType:"bytes32",name:"uid",type:"bytes32"}],name:"isAttestationValid",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Checks whether an attestation exists.",params:{uid:"The UID of the attestation to retrieve."},returns:{_0:"Whether an attestation exists."}},"multiAttest((bytes32,(address,uint64,bool,bytes32,bytes,uint256)[])[])":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct AttestationRequestData[]",name:"data",type:"tuple[]"}],internalType:"struct MultiAttestationRequest[]",name:"multiRequests",type:"tuple[]"}],name:"multiAttest",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"payable",type:"function",details:"Attests to multiple schemas.",params:{multiRequests:"The arguments of the multi attestation requests. The requests should be grouped by distinct schema ids to benefit from the best batching optimization. Example: multiAttest([{     schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',     data: [{         recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',         expirationTime: 1673891048,         revocable: true,         refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',         data: '0x1234',         value: 1000     },     {         recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',         expirationTime: 0,         revocable: false,         refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',         data: '0x00',         value: 0     }], }, {     schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',     data: [{         recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',         expirationTime: 0,         revocable: true,         refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',         data: '0x12345678',         value: 0     }, }])"},returns:{_0:"The UIDs of the new attestations."}},"multiAttestByDelegation((bytes32,(address,uint64,bool,bytes32,bytes,uint256)[],(uint8,bytes32,bytes32)[],address)[])":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct AttestationRequestData[]",name:"data",type:"tuple[]"},{components:[{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct EIP712Signature[]",name:"signatures",type:"tuple[]"},{internalType:"address",name:"attester",type:"address"}],internalType:"struct MultiDelegatedAttestationRequest[]",name:"multiDelegatedRequests",type:"tuple[]"}],name:"multiAttestByDelegation",outputs:[{internalType:"bytes32[]",name:"",type:"bytes32[]"}],stateMutability:"payable",type:"function",details:"Attests to multiple schemas using via provided EIP712 signatures.",params:{multiDelegatedRequests:"The arguments of the delegated multi attestation requests. The requests should be grouped by distinct schema ids to benefit from the best batching optimization. Example: multiAttestByDelegation([{     schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',     data: [{         recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',         expirationTime: 1673891048,         revocable: true,         refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',         data: '0x1234',         value: 0     },     {         recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',         expirationTime: 0,         revocable: false,         refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',         data: '0x00',         value: 0     }],     signatures: [{         v: 28,         r: '0x148c...b25b',         s: '0x5a72...be22'     },     {         v: 28,         r: '0x487s...67bb',         s: '0x12ad...2366'     }],     attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4' }])"},returns:{_0:"The UIDs of the new attestations."}},"multiRevoke((bytes32,(bytes32,uint256)[])[])":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct RevocationRequestData[]",name:"data",type:"tuple[]"}],internalType:"struct MultiRevocationRequest[]",name:"multiRequests",type:"tuple[]"}],name:"multiRevoke",outputs:[],stateMutability:"payable",type:"function",details:"Revokes existing attestations to multiple schemas.",params:{multiRequests:"The arguments of the multi revocation requests. The requests should be grouped by distinct schema ids to benefit from the best batching optimization. Example: multiRevoke([{     schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',     data: [{         uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',         value: 1000     },     {         uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',         value: 0     }], }, {     schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',     data: [{         uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',         value: 0     }, }])"}},"multiRevokeByDelegation((bytes32,(bytes32,uint256)[],(uint8,bytes32,bytes32)[],address)[])":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct RevocationRequestData[]",name:"data",type:"tuple[]"},{components:[{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct EIP712Signature[]",name:"signatures",type:"tuple[]"},{internalType:"address",name:"revoker",type:"address"}],internalType:"struct MultiDelegatedRevocationRequest[]",name:"multiDelegatedRequests",type:"tuple[]"}],name:"multiRevokeByDelegation",outputs:[],stateMutability:"payable",type:"function",details:"Revokes existing attestations to multiple schemas via provided EIP712 signatures.",params:{multiDelegatedRequests:"The arguments of the delegated multi revocation attestation requests. The requests should be grouped by distinct schema ids to benefit from the best batching optimization. Example: multiRevokeByDelegation([{     schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',     data: [{         uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',         value: 1000     },     {         uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',         value: 0     }],     signatures: [{         v: 28,         r: '0x148c...b25b',         s: '0x5a72...be22'     },     {         v: 28,         r: '0x487s...67bb',         s: '0x12ad...2366'     }],     revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992' }])"}},"multiRevokeOffchain(bytes32[])":{inputs:[{internalType:"bytes32[]",name:"data",type:"bytes32[]"}],name:"multiRevokeOffchain",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"nonpayable",type:"function",details:"Revokes the specified multiple bytes32 data.",params:{data:"The data to timestamp."},returns:{_0:"The timestamp the data was revoked with."}},"multiTimestamp(bytes32[])":{inputs:[{internalType:"bytes32[]",name:"data",type:"bytes32[]"}],name:"multiTimestamp",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"nonpayable",type:"function",details:"Timestamps the specified multiple bytes32 data.",params:{data:"The data to timestamp."},returns:{_0:"The timestamp the data was timestamped with."}},"revoke((bytes32,(bytes32,uint256)))":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct RevocationRequestData",name:"data",type:"tuple"}],internalType:"struct RevocationRequest",name:"request",type:"tuple"}],name:"revoke",outputs:[],stateMutability:"payable",type:"function",details:"Revokes an existing attestation to a specific schema. Example: revoke({     schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',     data: {         uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',         value: 0     } })",params:{request:"The arguments of the revocation request."}},"revokeByDelegation((bytes32,(bytes32,uint256),(uint8,bytes32,bytes32),address))":{inputs:[{components:[{internalType:"bytes32",name:"schema",type:"bytes32"},{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"uint256",name:"value",type:"uint256"}],internalType:"struct RevocationRequestData",name:"data",type:"tuple"},{components:[{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct EIP712Signature",name:"signature",type:"tuple"},{internalType:"address",name:"revoker",type:"address"}],internalType:"struct DelegatedRevocationRequest",name:"delegatedRequest",type:"tuple"}],name:"revokeByDelegation",outputs:[],stateMutability:"payable",type:"function",details:"Revokes an existing attestation to a specific schema via the provided EIP712 signature. Example: revokeByDelegation({     schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',     data: {         uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',         value: 0     },     signature: {         v: 27,         r: '0xb593...7142',         s: '0x0f5b...2cce'     },     revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992' })",params:{delegatedRequest:"The arguments of the delegated revocation request."}},"revokeOffchain(bytes32)":{inputs:[{internalType:"bytes32",name:"data",type:"bytes32"}],name:"revokeOffchain",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"nonpayable",type:"function",details:"Revokes the specified bytes32 data.",params:{data:"The data to timestamp."},returns:{_0:"The timestamp the data was revoked with."}},"timestamp(bytes32)":{inputs:[{internalType:"bytes32",name:"data",type:"bytes32"}],name:"timestamp",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"nonpayable",type:"function",details:"Timestamps the specified bytes32 data.",params:{data:"The data to timestamp."},returns:{_0:"The timestamp the data was timestamped with."}}}},"@ethereum-attestation-service/eas-contracts/contracts/ISchemaRegistry.sol:ISchemaRegistry":{source:"@ethereum-attestation-service/eas-contracts/contracts/ISchemaRegistry.sol",name:"ISchemaRegistry",title:"The global schema registry interface.",events:{"Registered(bytes32,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"uid",type:"bytes32"},{indexed:!1,internalType:"address",name:"registerer",type:"address"}],name:"Registered",type:"event",details:"Emitted when a new schema has been registered",params:{registerer:"The address of the account used to register the schema.",uid:"The schema UID."}}},methods:{"getSchema(bytes32)":{inputs:[{internalType:"bytes32",name:"uid",type:"bytes32"}],name:"getSchema",outputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"contract ISchemaResolver",name:"resolver",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"string",name:"schema",type:"string"}],internalType:"struct SchemaRecord",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns an existing schema by UID",params:{uid:"The UID of the schema to retrieve."},returns:{_0:"The schema data members."}},"register(string,address,bool)":{inputs:[{internalType:"string",name:"schema",type:"string"},{internalType:"contract ISchemaResolver",name:"resolver",type:"address"},{internalType:"bool",name:"revocable",type:"bool"}],name:"register",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function",details:"Submits and reserves a new schema",params:{resolver:"An optional schema resolver.",revocable:"Whether the schema allows revocations explicitly.",schema:"The schema data schema."},returns:{_0:"The UID of the new schema."}}}},"@ethereum-attestation-service/eas-contracts/contracts/resolver/ISchemaResolver.sol:ISchemaResolver":{source:"@ethereum-attestation-service/eas-contracts/contracts/resolver/ISchemaResolver.sol",name:"ISchemaResolver",title:"The interface of an optional schema resolver.",methods:{"attest((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes))":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"attestation",type:"tuple"}],name:"attest",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes an attestation and verifies whether it's valid.",params:{attestation:"The new attestation."},returns:{_0:"Whether the attestation is valid."}},"isPayable()":{inputs:[],name:"isPayable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Returns whether the resolver supports ETH transfers."},"multiAttest((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes)[],uint256[])":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation[]",name:"attestations",type:"tuple[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"multiAttest",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes multiple attestations and verifies whether they are valid.",params:{attestations:"The new attestations.",values:"Explicit ETH amounts which were sent with each attestation."},returns:{_0:"Whether all the attestations are valid."}},"multiRevoke((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes)[],uint256[])":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation[]",name:"attestations",type:"tuple[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"multiRevoke",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes revocation of multiple attestation and verifies they can be revoked.",params:{attestations:"The existing attestations to be revoked.",values:"Explicit ETH amounts which were sent with each revocation."},returns:{_0:"Whether the attestations can be revoked."}},"revoke((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes))":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"attestation",type:"tuple"}],name:"revoke",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes an attestation revocation and verifies if it can be revoked.",params:{attestation:"The existing attestation to be revoked."},returns:{_0:"Whether the attestation can be revoked."}}}},"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol:ClonesUpgradeable":{source:"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol",name:"ClonesUpgradeable",details:'https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as "clones". > To simply and cheaply clone contract functionality in an immutable way, this standard specifies > a minimal bytecode implementation that delegates all calls to a known, fixed address. The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2` (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the deterministic method. _Available since v3.4._'},"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol:Initializable":{source:"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol",name:"Initializable",details:'This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed behind a proxy. Since proxied contracts do not make use of a constructor, it\'s common to move constructor logic to an external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer function so it can only be called once. The {initializer} modifier provided by this contract will have this effect. The initialization functions use a version number. Once a version number is used, it is consumed and cannot be reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in case an upgrade adds a module that needs to be initialized. For example: [.hljs-theme-light.nopadding] ```solidity contract MyToken is ERC20Upgradeable {     function initialize() initializer public {         __ERC20_init("MyToken", "MTK");     } } contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {     function initializeV2() reinitializer(2) public {         __ERC20Permit_init("MyToken");     } } ``` TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}. CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure that all initializers are idempotent. This is not verified automatically as constructors are by Solidity. [CAUTION] ==== Avoid leaving a contract uninitialized. An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke the {_disableInitializers} function in the constructor to automatically lock it when it is deployed: [.hljs-theme-light.nopadding] ```',events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}}},"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol:IERC20Upgradeable":{source:"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol",name:"IERC20Upgradeable",details:"Interface of the ERC20 standard as defined in the EIP.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol:AddressUpgradeable":{source:"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol",name:"AddressUpgradeable",details:"Collection of functions related to the address type"},"@openzeppelin/contracts/access/AccessControl.sol:AccessControl":{source:"@openzeppelin/contracts/access/AccessControl.sol",name:"AccessControl",details:"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.",events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"@openzeppelin/contracts/access/IAccessControl.sol:IAccessControl":{source:"@openzeppelin/contracts/access/IAccessControl.sol",name:"IAccessControl",details:"External interface of AccessControl declared to support ERC165 detection.",events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},methods:{"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}}},"@openzeppelin/contracts/governance/utils/IVotes.sol:IVotes":{source:"@openzeppelin/contracts/governance/utils/IVotes.sol",name:"IVotes",details:"Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts. _Available since v4.5._",events:{"DelegateChanged(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegator",type:"address"},{indexed:!0,internalType:"address",name:"fromDelegate",type:"address"},{indexed:!0,internalType:"address",name:"toDelegate",type:"address"}],name:"DelegateChanged",type:"event",details:"Emitted when an account changes their delegate."},"DelegateVotesChanged(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"uint256",name:"previousBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBalance",type:"uint256"}],name:"DelegateVotesChanged",type:"event",details:"Emitted when a token transfer or delegate change results in changes to a delegate's number of votes."}},methods:{"delegate(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Delegates votes from the sender to `delegatee`."},"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",details:"Delegates votes from signer to `delegatee`."},"delegates(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the delegate that `account` has chosen."},"getPastTotalSupply(uint256)":{inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total supply of votes available at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block. NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes. Votes that have not been delegated are still part of total supply, even though they would not participate in a vote."},"getPastVotes(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block."},"getVotes(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current amount of votes that `account` has."}}},"@openzeppelin/contracts/proxy/utils/Initializable.sol:Initializable":{source:"@openzeppelin/contracts/proxy/utils/Initializable.sol",name:"Initializable",details:'This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed behind a proxy. Since proxied contracts do not make use of a constructor, it\'s common to move constructor logic to an external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer function so it can only be called once. The {initializer} modifier provided by this contract will have this effect. The initialization functions use a version number. Once a version number is used, it is consumed and cannot be reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in case an upgrade adds a module that needs to be initialized. For example: [.hljs-theme-light.nopadding] ```solidity contract MyToken is ERC20Upgradeable {     function initialize() initializer public {         __ERC20_init("MyToken", "MTK");     } } contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {     function initializeV2() reinitializer(2) public {         __ERC20Permit_init("MyToken");     } } ``` TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}. CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure that all initializers are idempotent. This is not verified automatically as constructors are by Solidity. [CAUTION] ==== Avoid leaving a contract uninitialized. An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke the {_disableInitializers} function in the constructor to automatically lock it when it is deployed: [.hljs-theme-light.nopadding] ```',events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}}},"@openzeppelin/contracts/security/ReentrancyGuard.sol:ReentrancyGuard":{source:"@openzeppelin/contracts/security/ReentrancyGuard.sol",name:"ReentrancyGuard",details:"Contract module that helps prevent reentrant calls to a function. Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them. TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]."},"@openzeppelin/contracts/utils/Address.sol:Address":{source:"@openzeppelin/contracts/utils/Address.sol",name:"Address",details:"Collection of functions related to the address type"},"@openzeppelin/contracts/utils/Context.sol:Context":{source:"@openzeppelin/contracts/utils/Context.sol",name:"Context",details:"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts."},"@openzeppelin/contracts/utils/Multicall.sol:Multicall":{source:"@openzeppelin/contracts/utils/Multicall.sol",name:"Multicall",details:"Provides a function to batch together multiple calls in a single external call. _Available since v4.1._",methods:{"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Receives and executes a batch of function calls on this contract."}}},"@openzeppelin/contracts/utils/Strings.sol:Strings":{source:"@openzeppelin/contracts/utils/Strings.sol",name:"Strings",details:"String operations."},"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol:MerkleProof":{source:"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol",name:"MerkleProof",details:"These functions deal with verification of Merkle Tree proofs. The tree and the proofs can be generated using our https://github.com/OpenZeppelin/merkle-tree[JavaScript library]. You will find a quickstart guide in the readme. WARNING: You should avoid using leaf values that are 64 bytes long prior to hashing, or use a hash function other than keccak256 for hashing leaves. This is because the concatenation of a sorted pair of internal nodes in the merkle tree could be reinterpreted as a leaf value. OpenZeppelin's JavaScript library generates merkle trees that are safe against this attack out of the box."},"@openzeppelin/contracts/utils/introspection/ERC165.sol:ERC165":{source:"@openzeppelin/contracts/utils/introspection/ERC165.sol",name:"ERC165",details:"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ``` Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"@openzeppelin/contracts/utils/introspection/IERC165.sol:IERC165":{source:"@openzeppelin/contracts/utils/introspection/IERC165.sol",name:"IERC165",details:"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"@openzeppelin/contracts/utils/math/Math.sol:Math":{source:"@openzeppelin/contracts/utils/math/Math.sol",name:"Math",details:"Standard math utilities missing in the Solidity language."},"@openzeppelin/contracts/utils/math/SignedMath.sol:SignedMath":{source:"@openzeppelin/contracts/utils/math/SignedMath.sol",name:"SignedMath",details:"Standard signed math utilities missing in the Solidity language."},"contracts/core/Allo.sol:Allo":{source:"contracts/core/Allo.sol",name:"Allo",title:"___            ___        ___        ___         /\\  \\          /\\__\\      /\\__\\      /\\  \\        /::\\  \\        /:/  /     /:/  /     /::\\  \\       /:/\\:\\  \\      /:/  /     /:/  /     /:/\\:\\  \\      /::\\~\\:\\  \\    /:/  /     /:/  /     /:/  \\:\\  \\     /:/\\:\\ \\:\\__\\  /:/__/     /:/__/     /:/__/ \\:\\__\\     \\/__\\:\\/:/  /  \\:\\  \\     \\:\\  \\     \\:\\  \\ /:/  /          \\::/  /    \\:\\  \\     \\:\\  \\     \\:\\  /:/  /          /:/  /      \\:\\  \\     \\:\\  \\     \\:\\/:/  /         /:/  /        \\:\\__\\     \\:\\__\\     \\::/  /         \\/__/          \\/__/      \\/__/      \\/__/",author:"allo-team",details:"This contract is used to create & manage pools as well as manage the protocol. It      is the core of all things Allo. Requirements: The contract must be initialized with the 'initialize()' function",notice:"The Allo core contract",events:{"BaseFeePaid(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"BaseFeePaid",type:"event"},"BaseFeeUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"baseFee",type:"uint256"}],name:"BaseFeeUpdated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"OwnershipHandoverCanceled(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"pendingOwner",type:"address"}],name:"OwnershipHandoverCanceled",type:"event",details:"The ownership handover to `pendingOwner` has been canceled."},"OwnershipHandoverRequested(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"pendingOwner",type:"address"}],name:"OwnershipHandoverRequested",type:"event",details:"An ownership handover to `pendingOwner` has been requested."},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event",details:"The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event."},"PercentFeeUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"percentFee",type:"uint256"}],name:"PercentFeeUpdated",type:"event"},"PoolCreated(uint256,bytes32,address,address,uint256,(uint256,string))":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"contract IStrategy",name:"strategy",type:"address"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"PoolCreated",type:"event",notice:"====================== ======= Events ======= ======================"},"PoolFunded(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"PoolFunded",type:"event"},"PoolMetadataUpdated(uint256,(uint256,string))":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"PoolMetadataUpdated",type:"event"},"RegistryUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"registry",type:"address"}],name:"RegistryUpdated",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"StrategyApproved(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyApproved",type:"event"},"StrategyRemoved(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyRemoved",type:"event"},"TreasuryUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"treasury",type:"address"}],name:"TreasuryUpdated",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FEE_DENOMINATOR()":{inputs:[],name:"FEE_DENOMINATOR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Fee denominator"},"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"addPoolManager(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_manager",type:"address"}],name:"addPoolManager",outputs:[],stateMutability:"nonpayable",type:"function",details:"emits 'RoleGranted()' event Requirements: The caller must be a pool admin",params:{_manager:"The address to add",_poolId:"The pool id"},notice:"Add a pool manager"},"addToCloneableStrategies(address)":{inputs:[{internalType:"address",name:"_strategy",type:"address"}],name:"addToCloneableStrategies",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only callable by the owner, emits the 'StrategyApproved()' event Requirements: The caller must be allo owner",params:{_strategy:"The address of the strategy"},notice:"Add a strategy to the allowlist"},"allocate(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Calls the internal _allocate() function Requirements: This will be determined by the strategy",params:{_data:"encoded data unique to the strategy for that pool",_poolId:"id of the pool"},notice:"passes _data & msg.sender through to the strategy for that pool"},"batchAllocate(uint256[],bytes[])":{inputs:[{internalType:"uint256[]",name:"_poolIds",type:"uint256[]"},{internalType:"bytes[]",name:"_datas",type:"bytes[]"}],name:"batchAllocate",outputs:[],stateMutability:"nonpayable",type:"function","custom:datas":"The encoded data will be specific to a given strategy requirements, reference the strategy implementation of allocate()",params:{_datas:"encoded data unique to the strategy for that pool",_poolIds:"ids of the pools"},notice:"vote to multiple pools Requirements: This will be determined by the strategy"},"batchRegisterRecipient(uint256[],bytes[])":{inputs:[{internalType:"uint256[]",name:"_poolIds",type:"uint256[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"batchRegisterRecipient",outputs:[{internalType:"address[]",name:"recipientIds",type:"address[]"}],stateMutability:"nonpayable",type:"function","custom:data":"The encoded data will be specific to a given strategy requirements, reference the strategy implementation of registerRecipient()",details:"Returns the recipientIds from the strategy that have been registered from calling this funciton Requirements: Encoded '_data' length must match _poolIds length or this will revert with MISMATCH()               Other requirements will be determined by the strategy",params:{_data:"Encoded data unique to a strategy that registerRecipient() requires",_poolIds:"Id of the pools"},returns:{recipientIds:"The recipientIds that have been registered"},notice:"Register multiple recipients to multiple pools"},"cancelOwnershipHandover()":{inputs:[],name:"cancelOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Cancels the two-step ownership handover to the caller, if any."},"completeOwnershipHandover(address)":{inputs:[{internalType:"address",name:"pendingOwner",type:"address"}],name:"completeOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`."},"createPool(bytes32,address,bytes,address,uint256,(uint256,string),address[])":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_strategy",type:"address"},{internalType:"bytes",name:"_initStrategyData",type:"bytes"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"createPool",outputs:[{internalType:"uint256",name:"poolId",type:"uint256"}],stateMutability:"payable",type:"function","custom:initstrategydata":"The encoded data will be specific to a given strategy requirements,    reference the strategy implementation of 'initialize()'",params:{_amount:"The amount of the token",_initStrategyData:"The data to initialize the strategy",_managers:"The managers of the pool",_metadata:"The metadata of the pool",_profileId:"The profileId of the pool",_token:"The address of the token"},notice:"Creates a new pool (by cloning a cloneable strategies) Requirements: 'msg.sender' must be owner or member of the profile id passed as '_profileId'"},"createPoolWithCustomStrategy(bytes32,address,bytes,address,uint256,(uint256,string),address[])":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_strategy",type:"address"},{internalType:"bytes",name:"_initStrategyData",type:"bytes"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"createPoolWithCustomStrategy",outputs:[{internalType:"uint256",name:"poolId",type:"uint256"}],stateMutability:"payable",type:"function","custom:initstrategydata":"The encoded data will be specific to a given strategy requirements, reference the strategy implementation of 'initialize()'",details:"Must be a member or owner of a profile to create a pool with or without a custom strategy Requirements: The strategy address passed must not be a cloneable strategy               The strategy address passed must not be the zero address               The caller must be a member or owner of the profile",params:{_amount:"The amount of the token you want to deposit into the pool on initialization",_initStrategyData:"The data to initialize the strategy",_managers:"The managers of the pool, and can be added/removed later by the pool admin",_metadata:"The metadata of the pool, this uses our 'Meatdata.sol' struct (consistent throughout the protocol)",_profileId:"The profileId of the pool, used to check if the caller is a member or owner of the profile",_strategy:"The address of the deployed custom strategy",_token:"The address of the token you want to use in your pool"},returns:{poolId:"The id of the pool"},notice:"Creates a new pool (with custom strategy)"},"distribute(uint256,address[],bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function","custom:data":"The encoded data will be specific to a given strategy requirements, reference the strategy implementation of distribute()",params:{_data:"encoded data unique to the strategy for that pool",_poolId:"id of the pool"},notice:"passes _data & msg.sender through to the disribution strategy for that pool Requirements: This will be determined by the strategy"},"fundPool(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"fundPool",outputs:[],stateMutability:"payable",type:"function",details:"Calls the internal _fundPool() function Requirements: None, anyone can fund a pool",params:{_amount:"extra amount of the token to be deposited into the pool",_poolId:"id of the pool"},notice:"Fund a pool"},"getBaseFee()":{inputs:[],name:"getBaseFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Getter for base fee"},"getPercentFee()":{inputs:[],name:"getPercentFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Getter for fee percentage"},"getPool(uint256)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"}],name:"getPool",outputs:[{components:[{internalType:"bytes32",name:"profileId",type:"bytes32"},{internalType:"contract IStrategy",name:"strategy",type:"address"},{internalType:"address",name:"token",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"bytes32",name:"managerRole",type:"bytes32"},{internalType:"bytes32",name:"adminRole",type:"bytes32"}],internalType:"struct IAllo.Pool",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Getter for the 'Pool'"},"getRegistry()":{inputs:[],name:"getRegistry",outputs:[{internalType:"contract IRegistry",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Getter for registry"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStrategy(uint256)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"}],name:"getStrategy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_poolId:"The pool id"},returns:{_0:"address"},notice:"Return the strategy for a pool"},"getTreasury()":{inputs:[],name:"getTreasury",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Getter for treasury address"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_registry",type:"address"},{internalType:"address payable",name:"_treasury",type:"address"},{internalType:"uint256",name:"_percentFee",type:"uint256"},{internalType:"uint256",name:"_baseFee",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"During upgrade -> an higher version should be passed to reinitializer",params:{_baseFee:"The base fee",_percentFee:"The percentage fee",_registry:"The address of the registry",_treasury:"The address of the treasury"},notice:"Initializes the contract after an upgrade"},"isCloneableStrategy(address)":{inputs:[{internalType:"address",name:"_strategy",type:"address"}],name:"isCloneableStrategy",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Getter for if strategy is cloneable"},"isPoolAdmin(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_address",type:"address"}],name:"isPoolAdmin",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_address:"The address to check",_poolId:"The pool id"},returns:{_0:"bool"},notice:"Checks if the address is a pool admin"},"isPoolManager(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_address",type:"address"}],name:"isPoolManager",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_address:"The address to check",_poolId:"The pool id"},returns:{_0:"bool"},notice:"Checks if the address is a pool manager"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"result",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the contract."},"ownershipHandoverExpiresAt(address)":{inputs:[{internalType:"address",name:"pendingOwner",type:"address"}],name:"ownershipHandoverExpiresAt",outputs:[{internalType:"uint256",name:"result",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`."},"recoverFunds(address,address)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_recipient",type:"address"}],name:"recoverFunds",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipient:"The address of the recipient",_token:"The address of the token to transfer"},notice:"Transfer thefunds recovered  to the recipient Requirements: The caller must be a pool owner"},"registerRecipient(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function","custom:data":"The encoded data will be specific to a given strategy requirements, reference the strategy implementation of registerRecipient()",params:{_data:"Encoded data unique to a strategy that registerRecipient() requires",_poolId:"Id of the pool"},returns:{_0:"recipientId The recipientId that has been registered"},notice:"Passes _data through to the strategy for that pool Requirements: This will be determined by the strategy"},"removeFromCloneableStrategies(address)":{inputs:[{internalType:"address",name:"_strategy",type:"address"}],name:"removeFromCloneableStrategies",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only callable by the owner, emits 'StrategyRemoved()' event Requirements: The caller must be allo owner",params:{_strategy:"The address of the strategy"},notice:"Remove a strategy from the allowlist"},"removePoolManager(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_manager",type:"address"}],name:"removePoolManager",outputs:[],stateMutability:"nonpayable",type:"function",details:"emits 'RoleRevoked()' event Requirements: The caller must be a pool admin",params:{_manager:"The address remove",_poolId:"The pool id"},notice:"Remove a pool manager"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to renounce their ownership."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"requestOwnershipHandover()":{inputs:[],name:"requestOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to transfer the ownership to `newOwner`."},"updateBaseFee(uint256)":{inputs:[{internalType:"uint256",name:"_baseFee",type:"uint256"}],name:"updateBaseFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"Use this to update the base fee Requirements: The caller must be allo owner",params:{_baseFee:"The new base fee"},notice:"Updates the base fee"},"updatePercentFee(uint256)":{inputs:[{internalType:"uint256",name:"_percentFee",type:"uint256"}],name:"updatePercentFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"Use this to update the fee percentage Requirements: The caller must be allo owner",params:{_percentFee:"The new fee"},notice:"Updates the fee percentage"},"updatePoolMetadata(uint256,(uint256,string))":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"updatePoolMetadata",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only callable by the pool managers, emits 'PoolMetadataUpdated()' event Requirements: The caller must be a pool manager",params:{_metadata:"new metadata of the pool",_poolId:"id of the pool"},notice:"Update pool metadata"},"updateRegistry(address)":{inputs:[{internalType:"address",name:"_registry",type:"address"}],name:"updateRegistry",outputs:[],stateMutability:"nonpayable",type:"function",details:"Use this to update the registry address Requirements: The caller must be allo owner",params:{_registry:"The new registry address"},notice:"Updates the registry address"},"updateTreasury(address)":{inputs:[{internalType:"address payable",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"Use this to update the treasury address Requirements: The caller must be allo owner",params:{_treasury:"The new treasury address"},notice:"Updates the treasury address"}}},"contracts/core/Anchor.sol:Anchor":{source:"contracts/core/Anchor.sol",name:"Anchor",title:"Anchor contract",details:"The Anhor is used as an primary entry point for the protocol and is an 'anchor' to your profileit gives the protocol a way to send funds to a target address and not get stuck in a contract",notice:"This contract is used to execute calls to a target address",constructor:{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute(address,uint256,bytes)":{inputs:[{internalType:"address",name:"_target",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"execute",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"nonpayable",type:"function",params:{_data:"The data to send to the target address",_target:"The target address to call",_value:"The amount of native token to send"},notice:"Execute a call to a target address"},"profileId()":{inputs:[],name:"profileId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The profileId of the allowed profile to execute calls"},"registry()":{inputs:[],name:"registry",outputs:[{internalType:"contract Registry",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The registry contract on any given network/chain"}}},"contracts/core/IAllo.sol:IAllo":{source:"contracts/core/IAllo.sol",name:"IAllo",events:{"BaseFeePaid(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"BaseFeePaid",type:"event"},"BaseFeeUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"baseFee",type:"uint256"}],name:"BaseFeeUpdated",type:"event"},"PercentFeeUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"percentFee",type:"uint256"}],name:"PercentFeeUpdated",type:"event"},"PoolCreated(uint256,bytes32,address,address,uint256,(uint256,string))":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"contract IStrategy",name:"strategy",type:"address"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"PoolCreated",type:"event",notice:"====================== ======= Events ======= ======================"},"PoolFunded(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"PoolFunded",type:"event"},"PoolMetadataUpdated(uint256,(uint256,string))":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"poolId",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"PoolMetadataUpdated",type:"event"},"RegistryUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"registry",type:"address"}],name:"RegistryUpdated",type:"event"},"StrategyApproved(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyApproved",type:"event"},"StrategyRemoved(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyRemoved",type:"event"},"TreasuryUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"treasury",type:"address"}],name:"TreasuryUpdated",type:"event"}},methods:{"FEE_DENOMINATOR()":{inputs:[],name:"FEE_DENOMINATOR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current fee denominator - set at 1e18 at launch"},"addPoolManager(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_manager",type:"address"}],name:"addPoolManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addToCloneableStrategies(address)":{inputs:[{internalType:"address",name:"_strategy",type:"address"}],name:"addToCloneableStrategies",outputs:[],stateMutability:"nonpayable",type:"function"},"allocate(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Allocates funds to a recipient and emits {Allocated} event if successful Note: Each strategy will handle the allocation of funds differently"},"batchAllocate(uint256[],bytes[])":{inputs:[{internalType:"uint256[]",name:"_poolIds",type:"uint256[]"},{internalType:"bytes[]",name:"_datas",type:"bytes[]"}],name:"batchAllocate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Allocates funds to multiple recipients and emits {Allocated} event if successful for each recipient Note: Each strategy will handle the allocation of funds differently"},"batchRegisterRecipient(uint256[],bytes[])":{inputs:[{internalType:"uint256[]",name:"_poolIds",type:"uint256[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"batchRegisterRecipient",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"nonpayable",type:"function",details:"Registers a batch of recipients and emits {Registered} event if successful for each recipient      and may be handled differently by each strategy Requirements: determined by the strategy"},"distribute(uint256,address[],bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Distributes funds to recipients and emits {Distributed} event if successful Note: Each strategy will handle the distribution of funds differently"},"fundPool(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"fundPool",outputs:[],stateMutability:"payable",type:"function",details:"Funds a pool and emits {PoolFunded} event if successful Requirements: None, but 'msg.value' must be greater than 0 if the token is the native token               or '_amount' must be greater than 0 if the token is not the native token"},"getBaseFee()":{inputs:[],name:"getBaseFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current base fee"},"getPercentFee()":{inputs:[],name:"getPercentFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current percent fee"},"getPool(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"getPool",outputs:[{components:[{internalType:"bytes32",name:"profileId",type:"bytes32"},{internalType:"contract IStrategy",name:"strategy",type:"address"},{internalType:"address",name:"token",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"bytes32",name:"managerRole",type:"bytes32"},{internalType:"bytes32",name:"adminRole",type:"bytes32"}],internalType:"struct IAllo.Pool",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns the 'Pool' struct for a given 'poolId'"},"getRegistry()":{inputs:[],name:"getRegistry",outputs:[{internalType:"contract IRegistry",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current registry address"},"getStrategy(uint256)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"}],name:"getStrategy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the strategy for a given 'poolId'"},"getTreasury()":{inputs:[],name:"getTreasury",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current treasury address"},"initialize(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_registry",type:"address"},{internalType:"address payable",name:"_treasury",type:"address"},{internalType:"uint256",name:"_percentFee",type:"uint256"},{internalType:"uint256",name:"_baseFee",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"==================================== ==== External/Public Functions ===== ===================================="},"isCloneableStrategy(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isCloneableStrategy",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Checks if a strategy is cloneable (is in the cloneableStrategies mapping) and returns a boolean"},"isPoolAdmin(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_address",type:"address"}],name:"isPoolAdmin",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Checks if an address is a pool admin and returns a boolean"},"isPoolManager(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_address",type:"address"}],name:"isPoolManager",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Checks if an address is a pool manager and returns a boolean"},"recoverFunds(address,address)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_recipient",type:"address"}],name:"recoverFunds",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Requirements: 'msg.sender' must be a pool admin"},"registerRecipient(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"Registers a recipient and emits {Registered} event if successful and may be handled differently by each strategy Requirements: determined by the strategy"},"removeFromCloneableStrategies(address)":{inputs:[{internalType:"address",name:"_strategy",type:"address"}],name:"removeFromCloneableStrategies",outputs:[],stateMutability:"nonpayable",type:"function"},"removePoolManager(uint256,address)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"address",name:"_manager",type:"address"}],name:"removePoolManager",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBaseFee(uint256)":{inputs:[{internalType:"uint256",name:"_baseFee",type:"uint256"}],name:"updateBaseFee",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePercentFee(uint256)":{inputs:[{internalType:"uint256",name:"_percentFee",type:"uint256"}],name:"updatePercentFee",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePoolMetadata(uint256,(uint256,string))":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"updatePoolMetadata",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRegistry(address)":{inputs:[{internalType:"address",name:"_registry",type:"address"}],name:"updateRegistry",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address payable",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/core/IRegistry.sol:IRegistry":{source:"contracts/core/IRegistry.sol",name:"IRegistry",title:"IRegistry Interface The Registry contract is used to store and manage all the profiles that are created within the Allo protocol",author:"allo-team",notice:"Interface for the Registry contract and exposes all functions needed to use the Registry         within the Allo protocol",events:{"ProfileCreated(bytes32,uint256,string,(uint256,string),address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"nonce",type:"uint256"},{indexed:!1,internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"},{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"anchor",type:"address"}],name:"ProfileCreated",type:"event",details:"Event emitted when a profile is created Note: This will return your anchor address"},"ProfileMetadataUpdated(bytes32,(uint256,string))":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"ProfileMetadataUpdated",type:"event",details:"Event emitted when a profile's metadata is updated"},"ProfileNameUpdated(bytes32,string,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"address",name:"anchor",type:"address"}],name:"ProfileNameUpdated",type:"event",details:"Event emitted when a profile name is updated Note: This will update the anchor when the name is updated and return it"},"ProfileOwnerUpdated(bytes32,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"address",name:"owner",type:"address"}],name:"ProfileOwnerUpdated",type:"event",details:"Event emitted when a profile owner is updated"},"ProfilePendingOwnerUpdated(bytes32,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"address",name:"pendingOwner",type:"address"}],name:"ProfilePendingOwnerUpdated",type:"event",details:"Event emitted when a profile pending owner is updated"}},methods:{"acceptProfileOwnership(bytes32)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"}],name:"acceptProfileOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Accepts the pending 'owner' of the '_profileId' passed in Requirements: Only the pending owner can accept the ownership"},"addMembers(bytes32,address[])":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"addMembers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Adds members to the '_profileId' passed in Requirements: Only the 'Profile' owner can add members"},"createProfile(uint256,string,(uint256,string),address,address[])":{inputs:[{internalType:"uint256",name:"_nonce",type:"uint256"},{internalType:"string",name:"_name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"},{internalType:"address",name:"_owner",type:"address"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"createProfile",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function",details:"Creates a new 'Profile' and returns the 'profileId' of the new profile Note: The 'name' and 'nonce' are used to generate the 'anchor' address Requirements: None, anyone can create a new profile"},"getProfileByAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"getProfileByAnchor",outputs:[{components:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"anchor",type:"address"}],internalType:"struct IRegistry.Profile",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns the 'Profile' for an '_anchor' passed"},"getProfileById(bytes32)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"}],name:"getProfileById",outputs:[{components:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"anchor",type:"address"}],internalType:"struct IRegistry.Profile",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns the 'Profile' for a '_profileId' passed"},"isMemberOfProfile(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_member",type:"address"}],name:"isMemberOfProfile",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns a boolean if the '_account' is a member of the '_profileId' passed in"},"isOwnerOfProfile(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_owner",type:"address"}],name:"isOwnerOfProfile",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns a boolean if the '_account' is an owner of the '_profileId' passed in"},"isOwnerOrMemberOfProfile(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_account",type:"address"}],name:"isOwnerOrMemberOfProfile",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns a boolean if the '_account' is a member or owner of the '_profileId' passed in"},"recoverFunds(address,address)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_recipient",type:"address"}],name:"recoverFunds",outputs:[],stateMutability:"nonpayable",type:"function",details:"Recovers funds from the contract Requirements: Must be the Allo owner"},"removeMembers(bytes32,address[])":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"removeMembers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Removes members from the '_profileId' passed in Requirements: Only the 'Profile' owner can remove members"},"updateProfileMetadata(bytes32,(uint256,string))":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"updateProfileMetadata",outputs:[],stateMutability:"nonpayable",type:"function",details:"Updates the 'metadata' of the '_profileId' passed in Requirements: Only the 'Profile' owner can update the metadata"},"updateProfileName(bytes32,string)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"string",name:"_name",type:"string"}],name:"updateProfileName",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Updates the 'name' of the '_profileId' passed in and returns the new 'anchor' address Requirements: Only the 'Profile' owner can update the name Note: The 'name' and 'nonce' are used to generate the 'anchor' address and this will update the 'anchor'       so please use caution. You can always recreate your 'anchor' address by updating the name back       to the original name used to create the profile."},"updateProfilePendingOwner(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_pendingOwner",type:"address"}],name:"updateProfilePendingOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"Updates the pending 'owner' of the '_profileId' passed in Requirements: Only the 'Profile' owner can update the pending owner"}}},"contracts/core/Registry.sol:Registry":{source:"contracts/core/Registry.sol",name:"Registry",title:"Registry",author:"allo-team",details:"This contract is used to create and manage profiles for the Allo protocol",notice:"Registry contract for creating and managing profiles",constructor:{inputs:[{internalType:"address",name:"_owner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"ProfileCreated(bytes32,uint256,string,(uint256,string),address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"nonce",type:"uint256"},{indexed:!1,internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"},{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"anchor",type:"address"}],name:"ProfileCreated",type:"event",details:"Event emitted when a profile is created Note: This will return your anchor address"},"ProfileMetadataUpdated(bytes32,(uint256,string))":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"ProfileMetadataUpdated",type:"event",details:"Event emitted when a profile's metadata is updated"},"ProfileNameUpdated(bytes32,string,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"address",name:"anchor",type:"address"}],name:"ProfileNameUpdated",type:"event",details:"Event emitted when a profile name is updated Note: This will update the anchor when the name is updated and return it"},"ProfileOwnerUpdated(bytes32,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"address",name:"owner",type:"address"}],name:"ProfileOwnerUpdated",type:"event",details:"Event emitted when a profile owner is updated"},"ProfilePendingOwnerUpdated(bytes32,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"address",name:"pendingOwner",type:"address"}],name:"ProfilePendingOwnerUpdated",type:"event",details:"Event emitted when a profile pending owner is updated"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},methods:{"ALLO_OWNER()":{inputs:[],name:"ALLO_OWNER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"Allo Owner Role for fund recovery"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"acceptProfileOwnership(bytes32)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"}],name:"acceptProfileOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only pending owner can claim ownership",params:{_profileId:"The profileId of the profile"},notice:"Transfers the ownership of the profile to the pending owner Requirements: Must be the pending owner of the profile to accept ownership"},"addMembers(bytes32,address[])":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"addMembers",outputs:[],stateMutability:"nonpayable",type:"function",params:{_members:"The members to add",_profileId:"The profileId of the profile"},notice:"Adds members to the profile Requirements: Must be the owner of the profile to add members"},"anchorToProfileId(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"anchorToProfileId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"anchor -> Profile.id"},"createProfile(uint256,string,(uint256,string),address,address[])":{inputs:[{internalType:"uint256",name:"_nonce",type:"uint256"},{internalType:"string",name:"_name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"},{internalType:"address",name:"_owner",type:"address"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"createProfile",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function",details:"This will also generate the 'profileId' and 'anchor' address, emits a {ProfileCreated} event Note: The 'nonce' is used to generate the 'profileId' and should be unique for each profile Note: The 'name' and 'profileId' are used to generate the 'anchor' address",params:{_members:"The members of the profile",_metadata:"The metadata of the profile",_name:"The name of the profile",_nonce:"Nonce used to generate profileId",_owner:"The owner of the profile"},notice:"Creates a new profile"},"getProfileByAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"getProfileByAnchor",outputs:[{components:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"anchor",type:"address"}],internalType:"struct IRegistry.Profile",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"This can be used when you have the 'anchor' address and want to retrieve the profile",params:{_anchor:"The anchor of the profile"},returns:{_0:"Profile The profile for the anchor passed"},notice:"Retrieve profile by anchor"},"getProfileById(bytes32)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"}],name:"getProfileById",outputs:[{components:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"anchor",type:"address"}],internalType:"struct IRegistry.Profile",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"This can be used when you have the 'profileId' and want to retrieve the profile",params:{_profileId:"The profileId of the profile"},returns:{_0:"Profile The profile for the profileId"},notice:"Retrieve profile by profileId"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isMemberOfProfile(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_member",type:"address"}],name:"isMemberOfProfile",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_member:"The address to check",_profileId:"The profileId of the profile"},returns:{_0:"bool Returns true if the address is an member of the profile"},notice:"Returns if the given address is an member of the profile"},"isOwnerOfProfile(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_owner",type:"address"}],name:"isOwnerOfProfile",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_owner:"The address to check",_profileId:"The profileId of the profile"},returns:{_0:"bool Returns true if the address is an owner of the profile"},notice:"Returns if the given address is an owner of the profile"},"isOwnerOrMemberOfProfile(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_account",type:"address"}],name:"isOwnerOrMemberOfProfile",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_account:"The address to check",_profileId:"The profileId of the profile"},returns:{_0:"bool Returns true if the address is an owner or member of the profile"},notice:"Returns if the given address is an owner or member of the profile"},"profileIdToPendingOwner(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"profileIdToPendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Profile.id -> pending owner"},"profilesById(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"profilesById",outputs:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"string",name:"name",type:"string"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"anchor",type:"address"}],stateMutability:"view",type:"function",notice:"Profile.id -> Profile"},"recoverFunds(address,address)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_recipient",type:"address"}],name:"recoverFunds",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfer thefunds recovered  to the recipient",params:{_recipient:"The address of the recipient Requirements: Only the Allo owner can recover funds",_token:"The address of the token to transfer"}},"removeMembers(bytes32,address[])":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"removeMembers",outputs:[],stateMutability:"nonpayable",type:"function",params:{_members:"The members to remove",_profileId:"The profileId of the profile"},notice:"Removes members from the profile Requirements: Must be the owner of the profile to remove members"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"updateProfileMetadata(bytes32,(uint256,string))":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"updateProfileMetadata",outputs:[],stateMutability:"nonpayable",type:"function",params:{_metadata:"The new metadata of the profile",_profileId:"The profileId of the profile"},notice:"Update the metadata of the profile Requirements: Must be the owner of the profile to update the metadata"},"updateProfileName(bytes32,string)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"string",name:"_name",type:"string"}],name:"updateProfileName",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Only owner can update the name",params:{_name:"The new name of the profile",_profileId:"The profileId of the profile"},notice:"Updates the name of the profile and generates new anchor Requirements: Must be the owner of the profile Note: Use caution when updating your profile name as it will generate a new anchor address Note: You can always update the name back to the original name to get the original anchor address"},"updateProfilePendingOwner(bytes32,address)":{inputs:[{internalType:"bytes32",name:"_profileId",type:"bytes32"},{internalType:"address",name:"_pendingOwner",type:"address"}],name:"updateProfilePendingOwner",outputs:[],stateMutability:"nonpayable",type:"function",params:{_pendingOwner:"New pending owner",_profileId:"The profileId of the profile"},notice:"Updates the pending owner of the profile Requirements: Must be the owner of the profile to update the owner"}}},"contracts/core/libraries/Clone.sol:Clone":{source:"contracts/core/libraries/Clone.sol",name:"Clone",title:"Clone library",details:"Handles the creation of clones for the strategy contracts and returns the address of the clone",notice:"A helper library to create deterministic clones of the strategy contracts when a pool is created"},"contracts/core/libraries/Native.sol:Native":{source:"contracts/core/libraries/Native.sol",name:"Native",title:"Native token information",details:"This is used to define the address of the native token for the protocol",methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"}}},"contracts/core/libraries/Transfer.sol:Transfer":{source:"contracts/core/libraries/Transfer.sol",name:"Transfer",title:"Transfer contract",details:"Handles the transfer of tokens to an address",notice:"A helper contract to transfer tokens within Allo protocol",methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"}}},"contracts/factory/ContractFactory.sol:ContractFactory":{source:"contracts/factory/ContractFactory.sol",name:"ContractFactory",title:"ContractFactory Contract",author:"allo-team",details:"ContractFactory is used internally to deploy our contracts using CREATE3",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Deployed(address,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"deployed",type:"address"},{indexed:!0,internalType:"bytes32",name:"salt",type:"bytes32"}],name:"Deployed",type:"event",details:"Emitted when a contract is deployed"}},methods:{"deploy(string,string,bytes)":{inputs:[{internalType:"string",name:"_contractName",type:"string"},{internalType:"string",name:"_version",type:"string"},{internalType:"bytes",name:"creationCode",type:"bytes"}],name:"deploy",outputs:[{internalType:"address",name:"deployedContract",type:"address"}],stateMutability:"payable",type:"function",params:{_contractName:"Name of the contract to deploy",_version:"Version of the contract to deploy",creationCode:"Creation code of the contract to deploy"},returns:{deployedContract:"Address of the deployed contract"},notice:"Deploys a contract using CREATE3"},"isDeployer(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isDeployer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"setDeployer(address,bool)":{inputs:[{internalType:"address",name:"_deployer",type:"address"},{internalType:"bool",name:"_allowedToDeploy",type:"bool"}],name:"setDeployer",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the '_deployer' to '_allowedToDeploy'",params:{_allowedToDeploy:"Boolean to set the deployer to",_deployer:"Address of the deployer to set"},notice:"Set the allowed deployer"},"usedSalts(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"usedSalts",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/strategies/BaseStrategy.sol:BaseStrategy":{source:"contracts/strategies/BaseStrategy.sol",name:"BaseStrategy",events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"The default BaseStrategy version will not use the data      if a strtegy wants to use it, they will overwrite it, use it, and then call super.initialize()"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"}}},"contracts/strategies/IStrategy.sol:IStrategy":{source:"contracts/strategies/IStrategy.sol",name:"IStrategy",title:"IStrategy Interface",author:"allo-team",details:"Interface for strategy imlementations, BaseStrategy inherits from this NOTE: BaseStrategy is the base contract that all strategies should inherit from",events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"}},methods:{"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Getter for the address of the Allo contract"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"The default BaseStrategy version will not use the data      if a strtegy wants to use it, they will overwrite it, use it, and then call super.initialize()"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"}}},"contracts/strategies/direct-grants-simple/DirectGrantsSimpleStrategy.sol:DirectGrantsSimpleStrategy":{source:"contracts/strategies/direct-grants-simple/DirectGrantsSimpleStrategy.sol",name:"DirectGrantsSimpleStrategy",title:"Direct Grants Simple Strategy",author:"allo-team",details:"This strategy is used to allocate & distribute funds to recipients with milestone payouts",notice:"A strategy is used to allocate & distribute funds to recipients with milestone payouts",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"MilestoneStatusChanged(address,uint256,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"milestoneId",type:"uint256"},{indexed:!1,internalType:"enum IStrategy.RecipientStatus",name:"status",type:"uint8"}],name:"MilestoneStatusChanged",type:"event",notice:"Event for the status change of a milestone"},"MilestoneSubmitted(address,uint256,(uint256,string))":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"milestoneId",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"MilestoneSubmitted",type:"event",notice:"Event for the submission of a milestone"},"MilestonesSet(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"recipientId",type:"address"}],name:"MilestonesSet",type:"event",notice:"Event for the milestones set"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusChanged(address,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum DirectGrantsSimpleStrategy.InternalRecipientStatus",name:"status",type:"uint8"}],name:"RecipientStatusChanged",type:"event",notice:"Event for the registration of a recipient and the status is updated"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocatedGrantAmount()":{inputs:[],name:"allocatedGrantAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum DirectGrantsSimpleStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"This status is specific to this strategy and is used to track the status of the recipient",params:{_recipientId:"Id of the recipient"},returns:{_0:"InternalRecipientStatus Returns the internal recipient status specific to this strategy"},notice:"Get Internal recipient status"},"getMilestoneStatus(address,uint256)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"},{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"getMilestoneStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"This is used to check the status of the milestone of an recipient and is strategy specific",params:{_milestoneId:"Id of the milestone",_recipientId:"Id of the recipient"},returns:{_0:"RecipientStatus Returns the status of the milestone using the 'RecipientStatus' enum"},notice:"Get the status of the milestone of an recipient"},"getMilestones(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getMilestones",outputs:[{components:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],internalType:"struct DirectGrantsSimpleStrategy.Milestone[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},returns:{_0:"Milestone[] Returns the milestones for a 'recipientId'"},notice:"Get the milestones"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"grantAmount",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum DirectGrantsSimpleStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"}],internalType:"struct DirectGrantsSimpleStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},returns:{_0:"Recipient Returns the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"grantAmountRequired()":{inputs:[],name:"grantAmountRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function","custom:data":"(bool registryGating, bool metadataRequired, bool grantAmountRequired)",params:{_data:"The data to be decoded",_poolId:"Id of the pool"},notice:"Initialize the strategy"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"milestones(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"milestones",outputs:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],stateMutability:"view",type:"function",notice:"This maps accepted recipients to their milestones"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registryGating()":{inputs:[],name:"registryGating",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"rejectMilestone(address,uint256)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"},{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"rejectMilestone",outputs:[],stateMutability:"nonpayable",type:"function",params:{_milestoneId:"Id of the milestone",_recipientId:"Id of the recipient"},notice:"Reject pending milestone of the recipient Requirements: Only the pool manager can reject the milestone"},"setIntenalRecipientStatusToInReview(address[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"}],name:"setIntenalRecipientStatusToInReview",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients"},notice:"Set the internal status of the recipient to InReview Requirements: Only the pool manager can set the status"},"setMilestones(address,(uint256,(uint256,string),uint8)[])":{inputs:[{internalType:"address",name:"_recipientId",type:"address"},{components:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],internalType:"struct DirectGrantsSimpleStrategy.Milestone[]",name:"_milestones",type:"tuple[]"}],name:"setMilestones",outputs:[],stateMutability:"nonpayable",type:"function",params:{_milestones:"The milestones to be set",_recipientId:"Id of the recipient"},notice:"Set milestones for recipient"},"submitMilestone(address,uint256,(uint256,string))":{inputs:[{internalType:"address",name:"_recipientId",type:"address"},{internalType:"uint256",name:"_milestoneId",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"submitMilestone",outputs:[],stateMutability:"nonpayable",type:"function",params:{_metadata:"The proof of work",_recipientId:"Id of the recipient"},notice:"Submit milestone by the recipient Requirements: Must be a member of a 'Profile' to sumbit a milestone and '_recipientId'               must NOT be the same as 'msg.sender'"},"upcomingMilestone(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"upcomingMilestone",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"This maps accepted recipients to their upcoming milestone"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"The amount to be withdrawn"},notice:"Withdraw funds from pool Requirements: Only the pool manager can withdraw"}}},"contracts/strategies/donation-voting-custom-registry/DonationVotingCustomRegistryStrategy.sol:DonationVotingCustomRegistryStrategy":{source:"contracts/strategies/donation-voting-custom-registry/DonationVotingCustomRegistryStrategy.sol",name:"DonationVotingCustomRegistryStrategy",title:"Donation Voting Custom Registry Strategy",author:"allo-team",notice:"This contract is a strategy that allows for donation voting with a custom registry.",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"=============================== ========== Events ============= ==============================="},"Claimed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"}],name:"Claimed",type:"event"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PayoutSet(bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes",name:"recipientIds",type:"bytes"}],name:"PayoutSet",type:"event"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum DonationVotingStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedTokens(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allowedTokens",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"token -> bool"},"claim((address,address)[])":{inputs:[{components:[{internalType:"address",name:"recipientId",type:"address"},{internalType:"address",name:"token",type:"address"}],internalType:"struct DonationVotingStrategy.Claim[]",name:"_claims",type:"tuple[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",params:{_claims:"Claims to be claimed"},notice:"Claim allocated tokens"},"claims(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"claims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId -> token -> amount"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum DonationVotingStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum DonationVotingStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"}],internalType:"struct DonationVotingStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ========= Initialize ========== ==============================="},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"payoutSummaries(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"payoutSummaries",outputs:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId -> PayoutSummary"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registry()":{inputs:[],name:"registry",outputs:[{internalType:"contract SimpleProjectRegistry",name:"",type:"address"}],stateMutability:"view",type:"function"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum DonationVotingStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"setPayout(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"uint256[]",name:"_amounts",type:"uint256[]"}],name:"setPayout",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amounts:"Amounts to be paid out",_recipientIds:"Ids of the recipients"},notice:"Set payout for the recipients"},"totalPayoutAmount()":{inputs:[],name:"totalPayoutAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"},"useRegistryAnchor()":{inputs:[],name:"useRegistryAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"The amount to be withdrawn"},notice:"Withdraw funds from pool"}}},"contracts/strategies/donation-voting-custom-registry/SimpleProjectRegistry.sol:SimpleProjectRegistry":{source:"contracts/strategies/donation-voting-custom-registry/SimpleProjectRegistry.sol",name:"SimpleProjectRegistry",title:"Simple Project Registry",author:"@0xZakk <zakk@gitcoin.co>",notice:"This contract is a simple implementation of a registry. It is intended to show that strategies can leverage their own registries. It assumes an owner, like a DAO, with explicit permission to add and remove projects from the registry.",constructor:{inputs:[{internalType:"address",name:"_initialOwner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"OwnershipHandoverCanceled(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"pendingOwner",type:"address"}],name:"OwnershipHandoverCanceled",type:"event",details:"The ownership handover to `pendingOwner` has been canceled."},"OwnershipHandoverRequested(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"pendingOwner",type:"address"}],name:"OwnershipHandoverRequested",type:"event",details:"An ownership handover to `pendingOwner` has been requested."},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event",details:"The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event."},"ProjectAdded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"project",type:"address"}],name:"ProjectAdded",type:"event",params:{project:"The project that was added"},notice:"Emitted when a project is added to the Registry"},"ProjectRemoved(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"project",type:"address"}],name:"ProjectRemoved",type:"event",params:{project:"The project that was removed"},notice:"Emitted when a project is removed from the Registry"}},methods:{"addProject(address)":{inputs:[{internalType:"address",name:"_project",type:"address"}],name:"addProject",outputs:[],stateMutability:"nonpayable",type:"function",params:{_project:"The project to add"},notice:"Add a project to the registry"},"addProjects(address[])":{inputs:[{internalType:"address[]",name:"_projects",type:"address[]"}],name:"addProjects",outputs:[],stateMutability:"nonpayable",type:"function",params:{_projects:"The projects to add"},notice:"Add an array projects to the registry"},"cancelOwnershipHandover()":{inputs:[],name:"cancelOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Cancels the two-step ownership handover to the caller, if any."},"completeOwnershipHandover(address)":{inputs:[{internalType:"address",name:"pendingOwner",type:"address"}],name:"completeOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"result",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the contract."},"ownershipHandoverExpiresAt(address)":{inputs:[{internalType:"address",name:"pendingOwner",type:"address"}],name:"ownershipHandoverExpiresAt",outputs:[{internalType:"uint256",name:"result",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`."},"projects(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"projects",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"The projects in the registry"},"removeProject(address)":{inputs:[{internalType:"address",name:"_project",type:"address"}],name:"removeProject",outputs:[],stateMutability:"nonpayable",type:"function",params:{_project:"The project to remove"},notice:"Remove a project from the registry"},"removeProjects(address[])":{inputs:[{internalType:"address[]",name:"_projects",type:"address[]"}],name:"removeProjects",outputs:[],stateMutability:"nonpayable",type:"function",params:{_projects:"The projects to remove"},notice:"Remove an array of projects from the registry"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to renounce their ownership."},"requestOwnershipHandover()":{inputs:[],name:"requestOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to transfer the ownership to `newOwner`."}}},"contracts/strategies/donation-voting-merkle-distribution/DonationVotingMerkleDistributionStrategy.sol:DonationVotingMerkleDistributionStrategy":{source:"contracts/strategies/donation-voting-merkle-distribution/DonationVotingMerkleDistributionStrategy.sol",name:"DonationVotingMerkleDistributionStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"=============================== ========== Events ============= ==============================="},"BatchPayoutSuccessful(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"BatchPayoutSuccessful",type:"event"},"Claimed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"}],name:"Claimed",type:"event"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"DistributionUpdated(bytes32,(uint256,string))":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes32",name:"merkleRoot",type:"bytes32"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],indexed:!1,internalType:"struct Metadata",name:"metadata",type:"tuple"}],name:"DistributionUpdated",type:"event"},"FundsDistributed(uint256,address,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"grantee",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"recipientId",type:"address"}],name:"FundsDistributed",type:"event"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"rowIndex",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fullRow",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedTokens(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allowedTokens",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"token -> bool"},"claim((address,address)[])":{inputs:[{components:[{internalType:"address",name:"recipientId",type:"address"},{internalType:"address",name:"token",type:"address"}],internalType:"struct DonationVotingMerkleDistributionStrategy.Claim[]",name:"_claims",type:"tuple[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",params:{_claims:"Claims to be claimed"},notice:"Claim allocated tokens"},"claims(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"claims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId -> token -> amount"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"distributionMetadata()":{inputs:[],name:"distributionMetadata",outputs:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],stateMutability:"view",type:"function",notice:"Metadata containing the distribution"},"distributionStarted()":{inputs:[],name:"distributionStarted",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum DonationVotingMerkleDistributionStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"}],internalType:"struct DonationVotingMerkleDistributionStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"hasBeenDistributed(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"hasBeenDistributed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_index:"index of the distribution"},notice:"Util function to check if distribution is done"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ========= Initialize ========== ==============================="},"isDistributionSet()":{inputs:[],name:"isDistributionSet",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"function to check if distribution is set"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"merkle root generated from distribution"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Receives and executes a batch of function calls on this contract."},"recipientToStatusIndexes(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipientToStatusIndexes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"recipientsCounter()":{inputs:[],name:"recipientsCounter",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewRecipients((uint256,uint256)[])":{inputs:[{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"uint256",name:"statusRow",type:"uint256"}],internalType:"struct DonationVotingMerkleDistributionStrategy.ApplicationStatus[]",name:"statuses",type:"tuple[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{statuses:"new statuses"},notice:"Set recipient statuses"},"statusesBitMap(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"statusesBitMap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalPayoutAmount()":{inputs:[],name:"totalPayoutAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateDistribution(bytes32,(uint256,string))":{inputs:[{internalType:"bytes32",name:"_merkleRoot",type:"bytes32"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_distributionMetadata",type:"tuple"}],name:"updateDistribution",outputs:[],stateMutability:"nonpayable",type:"function",params:{_distributionMetadata:"The metadata of the distribution",_merkleRoot:"The merkle root of the distribution"},notice:"Invoked by round operator to update the merkle root and distribution Metadata"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"},"useRegistryAnchor()":{inputs:[],name:"useRegistryAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"The amount to be withdrawn"},notice:"Withdraw funds from pool"}}},"contracts/strategies/donation-voting/DonationVotingStrategy.sol:DonationVotingStrategy":{source:"contracts/strategies/donation-voting/DonationVotingStrategy.sol",name:"DonationVotingStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"=============================== ========== Events ============= ==============================="},"Claimed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"}],name:"Claimed",type:"event"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PayoutSet(bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes",name:"recipientIds",type:"bytes"}],name:"PayoutSet",type:"event"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum DonationVotingStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedTokens(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allowedTokens",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"token -> bool"},"claim((address,address)[])":{inputs:[{components:[{internalType:"address",name:"recipientId",type:"address"},{internalType:"address",name:"token",type:"address"}],internalType:"struct DonationVotingStrategy.Claim[]",name:"_claims",type:"tuple[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",params:{_claims:"Claims to be claimed"},notice:"Claim allocated tokens"},"claims(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"claims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId -> token -> amount"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum DonationVotingStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum DonationVotingStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"}],internalType:"struct DonationVotingStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ========= Initialize ========== ==============================="},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"payoutSummaries(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"payoutSummaries",outputs:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId -> PayoutSummary"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum DonationVotingStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"setPayout(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"uint256[]",name:"_amounts",type:"uint256[]"}],name:"setPayout",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amounts:"Amounts to be paid out",_recipientIds:"Ids of the recipients"},notice:"Set payout for the recipients"},"totalPayoutAmount()":{inputs:[],name:"totalPayoutAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"},"useRegistryAnchor()":{inputs:[],name:"useRegistryAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"The amount to be withdrawn"},notice:"Withdraw funds from pool"}}},"contracts/strategies/proportional-payout/ProportionalPayoutStrategy.sol:ProportionalPayoutStrategy":{source:"contracts/strategies/proportional-payout/ProportionalPayoutStrategy.sol",name:"ProportionalPayoutStrategy",title:"Proportional Payout Strategy",author:"allo-team",notice:"This strategy allows the allocator to allocate votes to recipients",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"AllocationTimeSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"startTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"endTime",type:"uint256"}],name:"AllocationTimeSet",type:"event",notice:"===================== ======= Events ====== ====================="},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],internalType:"struct ProportionalPayoutStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"hasAllocated(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"hasAllocated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"nftId => has allocated"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ========= Initialize ========== ==============================="},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"maxRecipientsAllowed()":{inputs:[],name:"maxRecipientsAllowed",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nft()":{inputs:[],name:"nft",outputs:[{internalType:"contract ERC721",name:"",type:"address"}],stateMutability:"view",type:"function"},"paidOut(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"paidOut",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"recipientId => paid out"},"recipients(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipients",outputs:[{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId => Recipient"},"recipientsCounter()":{inputs:[],name:"recipientsCounter",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"setAllocationTime(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"setAllocationTime",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The allocation end timestamp",_allocationStartTime:"The allocation start timestamp"},notice:"Set the allocation start and end timestamps"},"totalAllocations()":{inputs:[],name:"totalAllocations",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/strategies/qv-base/QVBaseStrategy.sol:QVBaseStrategy":{source:"contracts/strategies/qv-base/QVBaseStrategy.sol",name:"QVBaseStrategy",events:{"Allocated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"address",name:"allocator",type:"address"}],name:"Allocated",type:"event"},"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"====================== ======= Events ======= ======================"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"Reviewed(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Reviewed",type:"event"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocators(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allocators",outputs:[{internalType:"uint256",name:"voiceCredits",type:"uint256"}],stateMutability:"view",type:"function",notice:"allocator address => Allocator"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],internalType:"struct QVBaseStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"==================================== =========== Initialize ============= ===================================="},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paidOut(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"paidOut",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"recipientId => paid out"},"recipients(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipients",outputs:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId => Recipient"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registryGating()":{inputs:[],name:"registryGating",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"reviewThreshold()":{inputs:[],name:"reviewThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewsByStatus(address,uint8)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],name:"reviewsByStatus",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalRecipientVotes()":{inputs:[],name:"totalRecipientVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"}}},"contracts/strategies/qv-governance/QVGovernanceERC20Votes.sol:QVGovernanceERC20Votes":{source:"contracts/strategies/qv-governance/QVGovernanceERC20Votes.sol",name:"QVGovernanceERC20Votes",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Allocated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"address",name:"allocator",type:"address"}],name:"Allocated",type:"event"},"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"====================== ======= Events ======= ======================"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"Reviewed(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Reviewed",type:"event"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocators(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allocators",outputs:[{internalType:"uint256",name:"voiceCredits",type:"uint256"}],stateMutability:"view",type:"function",notice:"allocator address => Allocator"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],internalType:"struct QVBaseStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"govToken()":{inputs:[],name:"govToken",outputs:[{internalType:"contract IVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"====================== ======= Storage ====== ======================"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_data:"The data",_poolId:"The pool id"},notice:"Initialize the strategy"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paidOut(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"paidOut",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"recipientId => paid out"},"recipients(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipients",outputs:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId => Recipient"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registryGating()":{inputs:[],name:"registryGating",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"reviewThreshold()":{inputs:[],name:"reviewThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewsByStatus(address,uint8)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],name:"reviewsByStatus",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"timestamp()":{inputs:[],name:"timestamp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalRecipientVotes()":{inputs:[],name:"totalRecipientVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"}}},"contracts/strategies/qv-hackathon/HackathonQVStrategy.sol:HackathonQVStrategy":{source:"contracts/strategies/qv-hackathon/HackathonQVStrategy.sol",name:"HackathonQVStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"address",name:"allocator",type:"address"}],name:"Allocated",type:"event"},"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"====================== ======= Events ======= ======================"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"Reviewed(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Reviewed",type:"event"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"VERSION()":{inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocators(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allocators",outputs:[{internalType:"uint256",name:"voiceCredits",type:"uint256"}],stateMutability:"view",type:"function",notice:"allocator address => Allocator"},"attest((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes))":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"attestation",type:"tuple"}],name:"attest",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes an attestation and verifies whether it's valid.",params:{attestation:"The new attestation."},returns:{_0:"Whether the attestation is valid."}},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"easInfo()":{inputs:[],name:"easInfo",outputs:[{internalType:"contract IEAS",name:"eas",type:"address"},{internalType:"contract ISchemaRegistry",name:"schemaRegistry",type:"address"},{internalType:"bytes32",name:"schemaUID",type:"bytes32"},{internalType:"string",name:"schema",type:"string"},{internalType:"bool",name:"revocable",type:"bool"}],stateMutability:"view",type:"function"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getAttestation(bytes32)":{inputs:[{internalType:"bytes32",name:"uid",type:"bytes32"}],name:"getAttestation",outputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Gets an attestation from the EAS contract using the UID",params:{uid:"The UUID of the attestation to get."}},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"",type:"address[]"},{internalType:"bytes[]",name:"",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"The payouts as an array of PayoutSummary structs"},notice:"Get the payouts for the recipients"},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],internalType:"struct QVBaseStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getSchema(bytes32)":{inputs:[{internalType:"bytes32",name:"uid",type:"bytes32"}],name:"getSchema",outputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"contract ISchemaResolver",name:"resolver",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"string",name:"schema",type:"string"}],internalType:"struct SchemaRecord",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Gets a schema from the SchemaRegistry contract using the UID",params:{uid:"The UID of the schema to get."}},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"indexToRecipientId(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"indexToRecipientId",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Initializes the strategy",params:{_data:"The data to initialize the strategy with",_poolId:"The pool ID for this strategy"}},"isAttestationExpired(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"isAttestationExpired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_recipientId:"The recipient ID to check"},notice:"Returns if the attestation is expired or not"},"isPayable()":{inputs:[],name:"isPayable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",returns:{_0:"True if the attestation is payable, false otherwise"},notice:"Returns if the this contract is payable or not"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"maxVoiceCreditsPerAllocator()":{inputs:[],name:"maxVoiceCreditsPerAllocator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"multiAttest((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes)[],uint256[])":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation[]",name:"attestations",type:"tuple[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"multiAttest",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes multiple attestations and verifies whether they are valid.",params:{attestations:"The new attestations.",values:"Explicit ETH amounts which were sent with each attestation."},returns:{_0:"Whether all the attestations are valid."}},"multiRevoke((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes)[],uint256[])":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation[]",name:"attestations",type:"tuple[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"multiRevoke",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes revocation of multiple attestation and verifies they can be revoked.",params:{attestations:"The existing attestations to be revoked.",values:"Explicit ETH amounts which were sent with each revocation."},returns:{_0:"Whether the attestations can be revoked."}},"nft()":{inputs:[],name:"nft",outputs:[{internalType:"contract ERC721",name:"",type:"address"}],stateMutability:"view",type:"function"},"paidOut(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"paidOut",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"recipientId => paid out"},"payoutPercentages(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"payoutPercentages",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"recipientIdToIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipientIdToIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"recipientIdToUID(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipientIdToUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"recipients(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipients",outputs:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId => Recipient"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registryGating()":{inputs:[],name:"registryGating",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"reviewThreshold()":{inputs:[],name:"reviewThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewsByStatus(address,uint8)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],name:"reviewsByStatus",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"revoke((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes))":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"attestation",type:"tuple"}],name:"revoke",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes an attestation revocation and verifies if it can be revoked.",params:{attestation:"The existing attestation to be revoked."},returns:{_0:"Whether the attestation can be revoked."}},"setAllowedRecipientIds(address[],uint64,bytes)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"uint64",name:"_expirationTime",type:"uint64"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"setAllowedRecipientIds",outputs:[],stateMutability:"nonpayable",type:"function",params:{_data:"The data to include in the attestation",_expirationTime:"The expiration time of the attestation",_recipientIds:"The recipient IDs to allow"},notice:"Set the allowed recipient IDs"},"setPayoutPercentages(uint256[])":{inputs:[{internalType:"uint256[]",name:"_payoutPercentages",type:"uint256[]"}],name:"setPayoutPercentages",outputs:[],stateMutability:"nonpayable",type:"function",params:{_payoutPercentages:"The payoutPercentages to set"},notice:"Set the winner payoutPercentages per rank"},"totalRecipientVotes()":{inputs:[],name:"totalRecipientVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"},"voiceCreditsUsedPerNftId(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"voiceCreditsUsedPerNftId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"votesByRank(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"votesByRank",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/strategies/qv-hackathon/SchemaResolver.sol:SchemaResolver":{source:"contracts/strategies/qv-hackathon/SchemaResolver.sol",name:"SchemaResolver",title:"A base resolver contract",receive:{stateMutability:"payable",type:"receive"},methods:{"VERSION()":{inputs:[],name:"VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"attest((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes))":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"attestation",type:"tuple"}],name:"attest",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes an attestation and verifies whether it's valid.",params:{attestation:"The new attestation."},returns:{_0:"Whether the attestation is valid."}},"isPayable()":{inputs:[],name:"isPayable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Returns whether the resolver supports ETH transfers."},"multiAttest((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes)[],uint256[])":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation[]",name:"attestations",type:"tuple[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"multiAttest",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes multiple attestations and verifies whether they are valid.",params:{attestations:"The new attestations.",values:"Explicit ETH amounts which were sent with each attestation."},returns:{_0:"Whether all the attestations are valid."}},"multiRevoke((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes)[],uint256[])":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation[]",name:"attestations",type:"tuple[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"multiRevoke",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes revocation of multiple attestation and verifies they can be revoked.",params:{attestations:"The existing attestations to be revoked.",values:"Explicit ETH amounts which were sent with each revocation."},returns:{_0:"Whether the attestations can be revoked."}},"revoke((bytes32,bytes32,uint64,uint64,uint64,bytes32,address,address,bool,bytes))":{inputs:[{components:[{internalType:"bytes32",name:"uid",type:"bytes32"},{internalType:"bytes32",name:"schema",type:"bytes32"},{internalType:"uint64",name:"time",type:"uint64"},{internalType:"uint64",name:"expirationTime",type:"uint64"},{internalType:"uint64",name:"revocationTime",type:"uint64"},{internalType:"bytes32",name:"refUID",type:"bytes32"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"attester",type:"address"},{internalType:"bool",name:"revocable",type:"bool"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct Attestation",name:"attestation",type:"tuple"}],name:"revoke",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"Processes an attestation revocation and verifies if it can be revoked.",params:{attestation:"The existing attestation to be revoked."},returns:{_0:"Whether the attestation can be revoked."}}}},"contracts/strategies/qv-nft-tiered/QVNftTieredStrategy.sol:QVNftTieredStrategy":{source:"contracts/strategies/qv-nft-tiered/QVNftTieredStrategy.sol",name:"QVNftTieredStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Allocated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"address",name:"allocator",type:"address"}],name:"Allocated",type:"event"},"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"AllocatedWithNft(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"address",name:"nft",type:"address"},{indexed:!1,internalType:"address",name:"allocator",type:"address"}],name:"AllocatedWithNft",type:"event",notice:"====================== ======= Events ======= ======================"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"====================== ======= Events ======= ======================"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"Reviewed(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Reviewed",type:"event"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocators(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allocators",outputs:[{internalType:"uint256",name:"voiceCredits",type:"uint256"}],stateMutability:"view",type:"function",notice:"allocator address => Allocator"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],internalType:"struct QVBaseStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_data:"The data",_poolId:"The pool id"},notice:"Initialize the strategy"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"maxVoiceCreditsPerNft(address)":{inputs:[{internalType:"contract ERC721",name:"",type:"address"}],name:"maxVoiceCreditsPerNft",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"nfts(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"nfts",outputs:[{internalType:"contract ERC721",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"====================== ======= Storage ====== ======================"},"paidOut(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"paidOut",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"recipientId => paid out"},"recipients(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipients",outputs:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId => Recipient"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registryGating()":{inputs:[],name:"registryGating",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"reviewThreshold()":{inputs:[],name:"reviewThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewsByStatus(address,uint8)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],name:"reviewsByStatus",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalRecipientVotes()":{inputs:[],name:"totalRecipientVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"},"voiceCreditsUsedPerNftId(address,uint256)":{inputs:[{internalType:"contract ERC721",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"voiceCreditsUsedPerNftId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/strategies/qv-simple/QVSimpleStrategy.sol:QVSimpleStrategy":{source:"contracts/strategies/qv-simple/QVSimpleStrategy.sol",name:"QVSimpleStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Allocated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"address",name:"allocator",type:"address"}],name:"Allocated",type:"event"},"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"AllocatorAdded(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"allocator",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"AllocatorAdded",type:"event"},"AllocatorRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"allocator",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"AllocatorRemoved",type:"event"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"====================== ======= Events ======= ======================"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"Reviewed(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Reviewed",type:"event"},"TimestampsUpdated(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"registrationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"registrationEndTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"addAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"addAllocator",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocator:"The allocator address"},notice:"Add allocator"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocators(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allocators",outputs:[{internalType:"uint256",name:"voiceCredits",type:"uint256"}],stateMutability:"view",type:"function",notice:"allocator address => Allocator"},"allowedAllocators(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allowedAllocators",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"allocator => bool"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getInternalRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getInternalRecipientStatus",outputs:[{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get Internal recipient status"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],internalType:"struct QVBaseStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_data:"The data",_poolId:"The pool id"},notice:"Initialize the strategy"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"maxVoiceCreditsPerAllocator()":{inputs:[],name:"maxVoiceCreditsPerAllocator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paidOut(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"paidOut",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"recipientId => paid out"},"recipients(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"recipients",outputs:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{internalType:"uint256",name:"totalVotesReceived",type:"uint256"}],stateMutability:"view",type:"function",notice:"recipientId => Recipient"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"registrationEndTime()":{inputs:[],name:"registrationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registrationStartTime()":{inputs:[],name:"registrationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registryGating()":{inputs:[],name:"registryGating",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"removeAllocator",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocator:"The allocator address"},notice:"Remove allocator"},"reviewRecipients(address[],uint8[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus[]",name:"_recipientStatuses",type:"uint8[]"}],name:"reviewRecipients",outputs:[],stateMutability:"nonpayable",type:"function",params:{_recipientIds:"Ids of the recipients",_recipientStatuses:"Statuses of the recipients"},notice:"Review recipient application"},"reviewThreshold()":{inputs:[],name:"reviewThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reviewsByStatus(address,uint8)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"enum QVBaseStrategy.InternalRecipientStatus",name:"",type:"uint8"}],name:"reviewsByStatus",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalRecipientVotes()":{inputs:[],name:"totalRecipientVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePoolTimestamps(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_registrationStartTime",type:"uint256"},{internalType:"uint256",name:"_registrationEndTime",type:"uint256"},{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"updatePoolTimestamps",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocationEndTime:"The end time for the allocation",_allocationStartTime:"The start time for the allocation",_registrationEndTime:"The end time for the registration",_registrationStartTime:"The start time for the registration"},notice:"Set the start and end dates for the pool"}}},"contracts/strategies/rfp-committee/RFPCommitteeStrategy.sol:RFPCommitteeStrategy":{source:"contracts/strategies/rfp-committee/RFPCommitteeStrategy.sol",name:"RFPCommitteeStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"MaxBidIncreased(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"maxBid",type:"uint256"}],name:"MaxBidIncreased",type:"event",notice:"=============================== ========== Events ============= ==============================="},"MilestoneRejected(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"milestoneId",type:"uint256"}],name:"MilestoneRejected",type:"event"},"MilestonesSet()":{anonymous:!1,inputs:[],name:"MilestonesSet",type:"event"},"MilstoneSubmitted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"milestoneId",type:"uint256"}],name:"MilstoneSubmitted",type:"event"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"Voted(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"voter",type:"address"}],name:"Voted",type:"event",notice:"=============================== ========== Events ============= ==============================="}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"acceptedRecipientId()":{inputs:[],name:"acceptedRecipientId",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getMilestone(uint256)":{inputs:[{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"getMilestone",outputs:[{components:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],internalType:"struct RFPSimpleStrategy.Milestone",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_milestoneId:"Id of the milestone"},notice:"Get the milestone"},"getMilestoneStatus(uint256)":{inputs:[{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"getMilestoneStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_milestoneId:"Id of the milestone"},notice:"Get the status of the milestone"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"",type:"address[]"},{internalType:"bytes[]",name:"",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",notice:"Returns the payout summary for the accepted recipient"},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"proposalBid",type:"uint256"},{internalType:"enum IStrategy.RecipientStatus",name:"recipientStatus",type:"uint8"}],internalType:"struct RFPSimpleStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increaseMaxBid(uint256)":{inputs:[{internalType:"uint256",name:"_maxBid",type:"uint256"}],name:"increaseMaxBid",outputs:[],stateMutability:"nonpayable",type:"function",params:{_maxBid:"The max bid to be set"},notice:"Update max bid for RFP pool"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ========= Initialize ========== ==============================="},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"maxBid()":{inputs:[],name:"maxBid",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"milestones(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"milestones",outputs:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],stateMutability:"view",type:"function"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"rejectMilestone(uint256)":{inputs:[{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"rejectMilestone",outputs:[],stateMutability:"nonpayable",type:"function",params:{_milestoneId:"Id of the milestone"},notice:"Reject pending milestone"},"setMilestones((uint256,(uint256,string),uint8)[])":{inputs:[{components:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],internalType:"struct RFPSimpleStrategy.Milestone[]",name:"_milestones",type:"tuple[]"}],name:"setMilestones",outputs:[],stateMutability:"nonpayable",type:"function",params:{_milestones:"The milestones to be set"},notice:"Set milestones for RFP pool"},"setPoolActive(bool)":{inputs:[{internalType:"bool",name:"_active",type:"bool"}],name:"setPoolActive",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ======= External/Custom ======= ==============================="},"submitUpcomingMilestone((uint256,string))":{inputs:[{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"submitUpcomingMilestone",outputs:[],stateMutability:"nonpayable",type:"function",params:{_metadata:"The proof of work"},notice:"Submit milestone to RFP pool"},"upcomingMilestone()":{inputs:[],name:"upcomingMilestone",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"useRegistryAnchor()":{inputs:[],name:"useRegistryAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"voteThreshold()":{inputs:[],name:"voteThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"votedFor(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"votedFor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"votes(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"votes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"The amount to be withdrawn"},notice:"Withdraw funds from RFP pool"}}},"contracts/strategies/rfp-simple/RFPSimpleStrategy.sol:RFPSimpleStrategy":{source:"contracts/strategies/rfp-simple/RFPSimpleStrategy.sol",name:"RFPSimpleStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"MaxBidIncreased(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"maxBid",type:"uint256"}],name:"MaxBidIncreased",type:"event",notice:"=============================== ========== Events ============= ==============================="},"MilestoneRejected(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"milestoneId",type:"uint256"}],name:"MilestoneRejected",type:"event"},"MilestonesSet()":{anonymous:!1,inputs:[],name:"MilestonesSet",type:"event"},"MilstoneSubmitted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"milestoneId",type:"uint256"}],name:"MilstoneSubmitted",type:"event"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"acceptedRecipientId()":{inputs:[],name:"acceptedRecipientId",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getMilestone(uint256)":{inputs:[{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"getMilestone",outputs:[{components:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],internalType:"struct RFPSimpleStrategy.Milestone",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_milestoneId:"Id of the milestone"},notice:"Get the milestone"},"getMilestoneStatus(uint256)":{inputs:[{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"getMilestoneStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_milestoneId:"Id of the milestone"},notice:"Get the status of the milestone"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"",type:"address[]"},{internalType:"bytes[]",name:"",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",notice:"Returns the payout summary for the accepted recipient"},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipient(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipient",outputs:[{components:[{internalType:"bool",name:"useRegistryAnchor",type:"bool"},{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"proposalBid",type:"uint256"},{internalType:"enum IStrategy.RecipientStatus",name:"recipientStatus",type:"uint8"}],internalType:"struct RFPSimpleStrategy.Recipient",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_recipientId:"Id of the recipient"},notice:"Get the recipient"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increaseMaxBid(uint256)":{inputs:[{internalType:"uint256",name:"_maxBid",type:"uint256"}],name:"increaseMaxBid",outputs:[],stateMutability:"nonpayable",type:"function",params:{_maxBid:"The max bid to be set"},notice:"Update max bid for RFP pool"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ========= Initialize ========== ==============================="},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"maxBid()":{inputs:[],name:"maxBid",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"metadataRequired()":{inputs:[],name:"metadataRequired",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"milestones(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"milestones",outputs:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],stateMutability:"view",type:"function"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"rejectMilestone(uint256)":{inputs:[{internalType:"uint256",name:"_milestoneId",type:"uint256"}],name:"rejectMilestone",outputs:[],stateMutability:"nonpayable",type:"function",params:{_milestoneId:"Id of the milestone"},notice:"Reject pending milestone"},"setMilestones((uint256,(uint256,string),uint8)[])":{inputs:[{components:[{internalType:"uint256",name:"amountPercentage",type:"uint256"},{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"metadata",type:"tuple"},{internalType:"enum IStrategy.RecipientStatus",name:"milestoneStatus",type:"uint8"}],internalType:"struct RFPSimpleStrategy.Milestone[]",name:"_milestones",type:"tuple[]"}],name:"setMilestones",outputs:[],stateMutability:"nonpayable",type:"function",params:{_milestones:"The milestones to be set"},notice:"Set milestones for RFP pool"},"setPoolActive(bool)":{inputs:[{internalType:"bool",name:"_active",type:"bool"}],name:"setPoolActive",outputs:[],stateMutability:"nonpayable",type:"function",notice:"=============================== ======= External/Custom ======= ==============================="},"submitUpcomingMilestone((uint256,string))":{inputs:[{components:[{internalType:"uint256",name:"protocol",type:"uint256"},{internalType:"string",name:"pointer",type:"string"}],internalType:"struct Metadata",name:"_metadata",type:"tuple"}],name:"submitUpcomingMilestone",outputs:[],stateMutability:"nonpayable",type:"function",params:{_metadata:"The proof of work"},notice:"Submit milestone to RFP pool"},"upcomingMilestone()":{inputs:[],name:"upcomingMilestone",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"useRegistryAnchor()":{inputs:[],name:"useRegistryAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"The amount to be withdrawn"},notice:"Withdraw funds from RFP pool"}}},"contracts/strategies/wrapped-voting-nftmint/NFT.sol:NFT":{source:"contracts/strategies/wrapped-voting-nftmint/NFT.sol",name:"NFT",constructor:{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint256",name:"_price",type:"uint256"},{internalType:"address",name:"_owner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when `owner` enables `account` to manage the `id` token."},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"isApproved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `owner` enables or disables `operator` to manage all of their tokens."},"OwnershipHandoverCanceled(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"pendingOwner",type:"address"}],name:"OwnershipHandoverCanceled",type:"event",details:"The ownership handover to `pendingOwner` has been canceled."},"OwnershipHandoverRequested(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"pendingOwner",type:"address"}],name:"OwnershipHandoverRequested",type:"event",details:"An ownership handover to `pendingOwner` has been requested."},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event",details:"The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when token `id` is transferred from `from` to `to`."}},methods:{"MINT_PRICE()":{inputs:[],name:"MINT_PRICE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"TOTAL_SUPPLY()":{inputs:[],name:"TOTAL_SUPPLY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"approve",outputs:[],stateMutability:"payable",type:"function",details:"Sets `account` as the approved account to manage token `id`. Requirements: - Token `id` must exist. - The caller must be the owner of the token,   or an approved operator for the token owner. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"result",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens owned by `owner`. Requirements: - `owner` must not be the zero address."},"cancelOwnershipHandover()":{inputs:[],name:"cancelOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Cancels the two-step ownership handover to the caller, if any."},"completeOwnershipHandover(address)":{inputs:[{internalType:"address",name:"pendingOwner",type:"address"}],name:"completeOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`."},"currentTokenId()":{inputs:[],name:"currentTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"id",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"result",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved to manage token `id`. Requirements: - Token `id` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"result",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether `operator` is approved to manage the tokens of `owner`."},"mintTo(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"mintTo",outputs:[],stateMutability:"payable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection name."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"result",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the contract."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"id",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"result",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of token `id`. Requirements: - Token `id` must exist."},"ownershipHandoverExpiresAt(address)":{inputs:[{internalType:"address",name:"pendingOwner",type:"address"}],name:"ownershipHandoverExpiresAt",outputs:[{internalType:"uint256",name:"result",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to renounce their ownership."},"requestOwnershipHandover()":{inputs:[],name:"requestOwnershipHandover",outputs:[],stateMutability:"payable",type:"function",details:"Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"payable",type:"function",details:'Equivalent to `safeTransferFrom(from, to, id, "")`.'},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"payable",type:"function",details:"Transfers token `id` from `from` to `to`. Requirements: - Token `id` must exist. - `from` must be the owner of the token. - `to` cannot be the zero address. - The caller must be the owner of the token, or be approved to manage the token. - If `to` refers to a smart contract, it must implement   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"isApproved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets whether `operator` is approved to manage the tokens of the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"result",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See: https://eips.ethereum.org/EIPS/eip-165 This function call must use less than 30000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection symbol."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"payable",type:"function",details:"Transfers token `id` from `from` to `to`. Requirements: - Token `id` must exist. - `from` must be the owner of the token. - `to` cannot be the zero address. - The caller must be the owner of the token, or be approved to manage the token. Emits a {Transfer} event."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"payable",type:"function",details:"Allows the owner to transfer the ownership to `newOwner`."},"withdrawPayments(address)":{inputs:[{internalType:"address payable",name:"payee",type:"address"}],name:"withdrawPayments",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/strategies/wrapped-voting-nftmint/NFTFactory.sol:NFTFactory":{source:"contracts/strategies/wrapped-voting-nftmint/NFTFactory.sol",name:"NFTFactory",events:{"NFTContractCreated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"nftContractAddress",type:"address"}],name:"NFTContractCreated",type:"event"}},methods:{"createNFTContract(string,string,uint256,address)":{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint256",name:"_price",type:"uint256"},{internalType:"address",name:"_owner",type:"address"}],name:"createNFTContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"isNFTContract(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isNFTContract",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/strategies/wrapped-voting-nftmint/WrappedVotingNftMintStrategy.sol:WrappedVotingNftMintStrategy":{source:"contracts/strategies/wrapped-voting-nftmint/WrappedVotingNftMintStrategy.sol",name:"WrappedVotingNftMintStrategy",constructor:{inputs:[{internalType:"address",name:"_allo",type:"address"},{internalType:"string",name:"_name",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Allocated(address,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Allocated",type:"event",notice:"Event emitted when a recipient is allocated to"},"Appealed(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Appealed",type:"event",notice:"=============================== ========== Events ============= ==============================="},"Claimed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"}],name:"Claimed",type:"event"},"Distributed(address,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"address",name:"recipientAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Distributed",type:"event",notice:"Event emitted when tokens are distributed"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Initialized(address,bytes32,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"allo",type:"address"},{indexed:!1,internalType:"bytes32",name:"profileId",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"poolId",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"Initialized",type:"event",notice:"Event emitted when strategy is initialized"},"PoolActive(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"active",type:"bool"}],name:"PoolActive",type:"event",notice:"Event emitted when pool is set to active status"},"RecipientStatusUpdated(address,uint8,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"enum WrappedVotingNftMintStrategy.InternalRecipientStatus",name:"recipientStatus",type:"uint8"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"RecipientStatusUpdated",type:"event"},"Registered(address,bytes,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"recipientId",type:"address"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Registered",type:"event",notice:"Event emitted when a recipient is registered"},"TimestampsUpdated(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"allocationStartTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocationEndTime",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"TimestampsUpdated",type:"event"}},methods:{"NATIVE()":{inputs:[],name:"NATIVE",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the native token"},"allocate(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"allocate",outputs:[],stateMutability:"payable",type:"function",details:"Only called via Allo.sol by users to allocate to a recipient      this will update some data in this contract to store votes, etc Requirements: This will be determined by the strategy"},"allocationEndTime()":{inputs:[],name:"allocationEndTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocationStartTime()":{inputs:[],name:"allocationStartTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allocations(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"allocations",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentWinner()":{inputs:[],name:"currentWinner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"distribute(address[],bytes,address)":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"This will distribute tokens to recipients NOTE: Most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference.       This contract will need to track the amount paid already, so that it doesn't double pay Requirements: This will be determined by the strategy"},"getAllo()":{inputs:[],name:"getAllo",outputs:[{internalType:"contract IAllo",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ =========== Views ============== ================================"},"getPayouts(address[],bytes[])":{inputs:[{internalType:"address[]",name:"_recipientIds",type:"address[]"},{internalType:"bytes[]",name:"_data",type:"bytes[]"}],name:"getPayouts",outputs:[{components:[{internalType:"address",name:"recipientAddress",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],internalType:"struct IStrategy.PayoutSummary[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Input the values you would send to distribute(), get the amounts each recipient in the array would receive"}},"getPoolAmount()":{inputs:[],name:"getPoolAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the amount of tokens in the pool"},"getPoolId()":{inputs:[],name:"getPoolId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Getter for the 'poolId' for this strategy"},"getRecipientStatus(address)":{inputs:[{internalType:"address",name:"_recipientId",type:"address"}],name:"getRecipientStatus",outputs:[{internalType:"enum IStrategy.RecipientStatus",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the status of a recipient probably tracked in a mapping, but will depend on the implementation      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those      since there is no need for Pending or Rejected"},"getStrategyId()":{inputs:[],name:"getStrategyId",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Getter for the 'id' of the strategy"},"increasePoolAmount(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"increasePoolAmount",outputs:[],stateMutability:"nonpayable",type:"function",notice:"incrases the poolAmount which is set on invoking Allo.fundPool"},"initialize(uint256,bytes)":{inputs:[{internalType:"uint256",name:"_poolId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_data:"The data containing the NFTFactory address, allocation start time, and allocation end time",_poolId:"The ID of the pool"},notice:"Initializes the WrappedVotingStrategy contract"},"isPoolActive()":{inputs:[],name:"isPoolActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"whether pool is active"},"isValidAllocator(address)":{inputs:[{internalType:"address",name:"_allocator",type:"address"}],name:"isValidAllocator",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether a allocator is valid or not, will usually be true for all      and will depend on the strategy implementation"},"nftFactory()":{inputs:[],name:"nftFactory",outputs:[{internalType:"contract NFTFactory",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"================================ ========== Storage ============= ================================"},"registerRecipient(bytes,address)":{inputs:[{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"address",name:"_sender",type:"address"}],name:"registerRecipient",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"payable",type:"function",details:"This is called via Allo.sol to register recipients      it can change their status all the way to Accepted, or to Pending if there are more steps      if there are more steps, additional functions should be added to allow the owner to check      this could also check attestations directly and then Accept Requirements: This will be determined by the strategy"},"setAllocationTimes(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_allocationStartTime",type:"uint256"},{internalType:"uint256",name:"_allocationEndTime",type:"uint256"}],name:"setAllocationTimes",outputs:[],stateMutability:"nonpayable",type:"function",notice:"==================== ===== External ===== ===================="}}}};new Wn({el:"#app",router:new Id({routes:[{path:"/",component:Gd,props:()=>({json:Hd})},{path:"*",component:zd,props:e=>({json:Hd[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(Sd)})})()})();